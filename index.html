<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DUO UP Profiles & Friends (Client-Only)</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js"></script>
<style>
/* --- BASE STYLES --- */
body { margin:0; font-family:'Orbitron',sans-serif; background:#0b0b0b; color:white; }
.container { width:90%; max-width:1000px; margin:auto; padding:20px; }
.hidden { display:none !important; }
.header { background:#111; border-bottom:3px solid cyan; box-shadow:0 0 20px rgba(0,255,255,0.5); padding:10px 0; margin-bottom:20px; display:flex; align-items:center; justify-content:center; }
.header h1 { font-size:2.5em; color:#fff; text-shadow:0 0 5px cyan,0 0 10px cyan,0 0 15px magenta; margin:0; }
.icon-container { margin-right:15px; font-size:2.5em; color:cyan; text-shadow:0 0 5px cyan,0 0 10px magenta; }
.neon-btn { border:2px solid cyan; background:transparent; color:white; padding:8px 14px; margin:5px; border-radius:6px; cursor:pointer; box-shadow:0 0 10px cyan; transition:all 0.2s ease-in-out; text-transform:uppercase; font-family:'Orbitron',sans-serif; white-space: nowrap; }
.neon-btn:hover { border-color:magenta; box-shadow:0 0 15px magenta; }
.neon-btn:disabled { border-color: #555; box-shadow: none; color: #555; cursor: not-allowed; }
.neon-btn.remove { border-color:red; box-shadow:0 0 10px red; }
.neon-btn.remove:hover { border-color:orange; box-shadow:0 0 15px orange; }
.neon-btn.accept { border-color:lime; box-shadow:0 0 10px lime; }
.neon-btn.accept:hover { border-color:green; box-shadow:0 0 15px green; }
#messageInput, #profileBio, #profileSkillRating, #profileStatus, #searchInput, #statusFilter, #skillFilter, #profileNickname, #newUsernameInput { flex-grow:1; padding:10px; border:1px solid cyan; background:#181818; color:white; border-radius:6px; font-family:inherit; outline:none; }
#messageInput:focus, #profileBio:focus, #profileSkillRating:focus, #profileStatus:focus, #newUsernameInput:focus { border-color: magenta; box-shadow: 0 0 8px magenta; }
#profileBio { resize: vertical; }
#profileSkillRating, #profileStatus { width: 100%; max-width: 200px; }
.flex { display:flex; gap:15px; flex-wrap:wrap; justify-content:center; }
.card-container { display:flex; flex-wrap:wrap; gap:15px; justify-content:center; }

/* --- USER CARD --- */
.card {
    width: 100%;
    max-width: 320px; 
    padding: 15px;
    border: 3px solid transparent; 
    border-radius: 6px;
    background: #181818; 
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.4), inset 0 0 5px rgba(0, 255, 255, 0.2);
    border-image-source: linear-gradient(45deg, cyan, magenta, cyan);
    border-image-slice: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 15px;
    cursor: pointer;
    overflow: hidden;
    transition: transform 0.2s, box-shadow 0.2s;
}
.card:hover {
    transform: translateY(-3px);
    box-shadow: 0 0 25px magenta, inset 0 0 10px rgba(255, 0, 255, 0.5); 
}
.card-content-box { 
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    margin-bottom: 10px; 
    padding-bottom: 10px;
    border-bottom: 1px dashed #333; 
}
.avatar { width:60px; height:60px; border-radius:50%; border:3px solid magenta; object-fit:cover; margin-bottom:10px; }
.card-gamer-preview {
    width: 100%;
    height: 120px;
    object-fit: cover;
    margin-top: 10px;
    border-radius: 4px;
    border: 1px solid cyan;
    box-shadow: inset 0 0 5px cyan;
}

/* --- OWNER BADGE (UPDATED) --- */
.owner-badge-box { 
    display:inline-block; 
    padding:2px 6px; 
    margin-left:8px; 
    font-size:0.7em; 
    font-weight:bold; 
    letter-spacing:1px; 
    border-radius:4px; 
    text-transform:uppercase; 
    background:#3a005c; 
    color:#ffccff;
    border:1px solid #ff00ff; 
    box-shadow:0 0 5px #ff00ff, 0 0 10px #cc33ff, inset 0 0 5px #ff00ff; 
    vertical-align:middle; 
    font-size: 0.8em; 
}
.owner-badge-box:before {
    content: "⚡ "; /* DUO UP Icon */
    color: yellow;
    text-shadow: 0 0 5px yellow;
    margin-right: 2px;
}
/* --- END OWNER BADGE --- */

.skill-rating { color:gold; font-size:1.2em; margin-bottom:5px; }
.status-indicator { font-size:0.8em; padding:3px 8px; border-radius:4px; font-weight:bold; margin-bottom:10px; }
.status-online { background-color:#00cc00; color:#0b0b0b; box-shadow:0 0 5px #00ff00; }
.status-ingame { background-color:#ffaa00; color:#0b0b0b; box-shadow:0 0 5px #ffaa00; }
.status-lfd { background-color:#00aaff; color:#0b0b0b; box-shadow:0 0 5px #00aaff; }
.unread-badge { background-color:magenta; color:white; border-radius:50%; padding:2px 7px; margin-left:5px; font-size:0.7em; font-weight:bold; box-shadow:0 0 5px magenta; }

/* --- GAME SLOTS STYLES --- */
.game-slot-container {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 15px;
}
.game-slot {
    width: 220px;
    border: 2px solid #5a005a;
    border-radius: 8px;
    padding: 10px;
    background: #181818;
    box-shadow: 0 0 8px #ff00ff;
    position: relative;
}
.game-slot h4 {
    margin-top: 0;
    margin-bottom: 8px;
    color: cyan;
    font-size: 1em;
}
.game-slot select, .game-slot input {
    width: 100%;
    padding: 5px;
    margin-bottom: 5px;
    border: 1px solid cyan;
    background: #0d0d0d;
    color: white;
    border-radius: 4px;
    box-sizing: border-box; 
}

/* --- USER CARD GAME DISPLAY --- */
.card-games {
    width: 100%;
    margin-top: 10px;
    padding-top: 10px;
    text-align: center;
}
.card-games p {
    margin: 3px 0;
    font-size: 0.85em;
    color: lime;
    line-height: 1.2;
}
.game-badge {
    display: inline-block;
    background: #004444; 
    color: #ccffff;
    padding: 3px 8px;
    border-radius: 4px;
    margin: 4px; 
    font-weight: bold;
    font-size: 0.85em;
    border: 1px solid cyan;
}


@media (max-width: 600px) { 
    .header h1 { font-size: 1.5em; } 
    .icon-container { font-size: 1.5em; } 
    .dashboard div { display: flex; flex-wrap: wrap; justify-content: center; } 
    .card { max-width: 100%; } 
}
</style>
</head>
<body>

<div class="header"><div class="icon-container">⚡</div><h1>DUO UP</h1></div>

<div id="loginPage" class="container">
<p style="text-align:center;">Find your perfect partner and dominate the cyber-arena.</p>
<div style="text-align:center;">
<button class="neon-btn" onclick="login()">Login with Google</button>
</div>
</div>

<div id="dashboard" class="container hidden">
<h2 id="welcome"></h2>
<div id="navigationBar" style="margin-bottom:20px;">
<button class="neon-btn" onclick="showTab('allUsers')">Suggested</button>
<button class="neon-btn" onclick="showTab('search')">Find Players</button>
<button class="neon-btn" onclick="showTab('requests')">Requests</button>
<button id="friendsBtn" class="neon-btn" onclick="showTab('friends')">Duos</button>
<button class="neon-btn" onclick="showTab('messaging')">Messaging</button>
<button class="neon-btn" onclick="showTab('profile')">Profile</button>
<button class="neon-btn" onclick="logout()">Logout</button>
</div>

<div id="allUsersTab" class="card-container"></div>

<div id="searchTab" class="hidden container">
    <h2>Player Search Filter</h2>
    <div id="searchControls" style="display:flex; gap:15px; margin-bottom:20px; align-items:center;">
        <input type="text" id="searchInput" placeholder="Search by Nickname or Bio..." onkeyup="filterSearchResults()">
        <label style="color:cyan;">Filter Status:</label>
        <select id="statusFilter" onchange="filterSearchResults()">
            <option value="">Any Status</option>
            <option value="Online">Online</option>
            <option value="In Game">In Game</option>
            <option value="LFD">Looking For Duo (LFD)</option>
        </select>
        <label style="color:cyan;">Min Skill:</label>
        <select id="skillFilter" onchange="filterSearchResults()">
            <option value="0">Any Skill</option>
            <option value="1">⭐ 1+</option>
            <option value="2">⭐⭐ 2+</option>
            <option value="3">⭐⭐⭐ 3+</option>
            <option value="4">⭐⭐⭐⭐ 4+</option>
            <option value="5">⭐⭐⭐⭐⭐ 5</option>
        </select>
    </div>
    <div id="searchResults" class="card-container"></div>
</div>

<div id="requestsTab" class="flex hidden"></div>
<div id="friendsTab" class="flex hidden"></div>

<div id="messagingTab" class="hidden">
<div id="chatList">
<h3>Active Duos</h3>
<div id="activeDuoList">No Duos to chat with.</div>
</div>

<div id="chatWindow">
<h3 id="chatHeader">Select a Duo</h3>
<div id="messageDisplay"></div>
<div id="messageInputArea" class="hidden" style="display:flex; gap:10px;">
<input type="text" id="messageInput" placeholder="Type your message...">
<button class="neon-btn" id="sendMessageBtn">Send</button>
</div>
</div>
</div>

<div id="viewProfileTab" class="hidden container">
    <button class="neon-btn" onclick="showTab('allUsers')">← Back to Suggested</button>
    <div id="viewProfileContent" style="padding: 20px; border: 2px solid magenta; border-radius: 10px; background: #1a1a1a; margin-top: 20px;">
        </div>
</div>

<div id="profileTab" class="hidden">
    <h2>Cyber-Profile Editor</h2>
    <div style="padding: 20px; border: 2px solid magenta; border-radius: 10px; background: #1a1a1a;">
        <div style="display: flex; align-items: center; margin-bottom: 20px;">
            <img id="profileAvatar" class="avatar" style="width: 80px; height: 80px; margin-right: 20px; border-color: magenta;" src="">
            <div>
                <label style="color: cyan; display: block; margin-bottom: 5px;">Unique Identifier:</label>
                <input type="text" id="profileNickname" value="User Nickname" disabled>
            </div>
        </div>
        <div style="margin-bottom: 15px;">
            <label style="color: cyan; display: block; margin-bottom: 5px;">Upload Avatar:</label>
            <input type="file" id="avatarUpload" accept="image/*" onchange="previewAvatar(this)">
        </div>

        <h3 style="color:cyan; margin-top: 25px;">Unique Username (@)</h3>
        <p id="usernameDisplay">@Loading...</p>
        <div id="usernameEditor" style="margin-bottom: 20px;">
            <input type="text" id="newUsernameInput" placeholder="Enter new username (a-z, 0-9, 3-20 chars)" style="flex-grow: 1;">
            <button class="neon-btn" id="changeUsernameBtn" onclick="attemptUsernameChange()">Set/Change Username</button>
        </div>
        <p id="usernameMessage" style="color: yellow;"></p>
            
        <div style="margin-bottom: 15px;">
            <label style="color: cyan; display: block; margin-bottom: 5px;">Bio/Tagline:</label>
            <textarea id="profileBio" rows="3" style="width: 100%;"></textarea>
        </div>
        <div style="display: flex; gap: 30px; margin-bottom: 20px;">
            <div>
                <label style="color: cyan; display: block; margin-bottom: 5px;">Skill Rating (1-5):</label>
                <select id="profileSkillRating">
                    <option value="1">⭐</option>
                    <option value="2">⭐⭐</option>
                    <option value="3">⭐⭐⭐</option>
                    <option value="4">⭐⭐⭐⭐</option>
                    <option value="5">⭐⭐⭐⭐⭐</option>
                </select>
            </div>
            <div>
                <label style="color: cyan; display: block; margin-bottom: 5px;">Current Status:</label>
                <select id="profileStatus">
                    <option value="Online">Online</option>
                    <option value="In Game">In Game</option>
                    <option value="LFD">Looking For Duo (LFD)</option>
                </select>
            </div>
        </div>
        
        <h3 style="color:cyan; margin-top: 25px;">Featured Games & Needs (Max 4)</h3>
        <button class="neon-btn" onclick="addGameSlot()" id="addGameBtn">Add Game</button>
        <div id="gameSlotList" class="game-slot-container">
            </div>

        <h3 style="color:cyan; margin-top: 25px;">Gamer Card Manager (Max 8)</h3>
        <p style="font-size: 0.9em; color: gray;">Click the "+" slot to upload a new card (Max 2MB per image).</p>
        <div id="gamerCardList" class="gamer-card-container" style="border: 1px dashed cyan; padding: 10px; border-radius: 6px; margin-bottom: 15px;"></div>
        <button class="neon-btn" style="border-color: #00ff00; box-shadow: 0 0 10px #00ff00;" onclick="saveProfile()">Save Profile</button>
        <p id="saveMessage" style="color: #00ff00; margin-top: 10px;"></p>
    </div>
</div>

<script>
// ---------- FIREBASE INIT (YOUR CONFIG) ----------
const firebaseConfig = {
    apiKey: "AIzaSyDVHxatohLvJNqIHXjf1ZXdmmWX5W1EpNw",    
    authDomain: "duoup-cfae6.firebaseapp.com",
    projectId: "duoup-cfae6",
    storageBucket: "duoup-cfae6.firebasestorage.app",
    messagingSenderId: "812263060524",
    appId: "1:812263060524:web:ac09c3ae610db1cd110d89",
    measurementId: "G-46B67F90FK"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
const storage = firebase.storage();

// OWNER UID (Used for a display badge)
const OWNER_UID = "DecuxiBRxoSwb8wKMmaHQql9HQ2"; 
const DEFAULT_AVATAR = "https://cdn-icons-png.flaticon.com/512/149/149071.png";

// Common Game and Role Lists for Selection
const GAMES_LIST = [
    { name: "Apex Legends", roles: ["Tank", "DPS", "Support", "Any"] },
    { name: "Valorant", roles: ["Duelist", "Controller", "Sentinel", "Initiator", "Any"] },
    { name: "League of Legends", roles: ["Top", "Jungle", "Mid", "ADC", "Support", "Any"] },
    { name: "Dota 2", roles: ["Carry", "Mid", "Offlane", "Support 4", "Support 5", "Any"] },
    { name: "Overwatch 2", roles: ["Tank", "DPS", "Support", "Any"] },
    { name: "Fortnite", roles: ["Builder", "Zero Build", "Any"] },
    { name: "Destiny 2", roles: ["PVE", "PVP", "Any"] },
    { name: "Rocket League", roles: ["Attacker", "Defender", "Midfield", "Any"] },
    { name: "Other/Casual", roles: ["Chill", "Competitive", "Casual"] }
];

// Global State
let currentUser = null, 
    currentChatUid = null, 
    unsubscribeMessages = null, 
    unsubscribeUnread = null; 
let currentProfileData = {}; 
let pendingRequests = {}; 
let sentRequests = {};   
let allUsersCache = [];    
let friendUsers = {}; 
let blockedUsers = {}; // UIDs blocked by the current user

function getChatId(a,b){ return [a,b].sort().join('_'); }

// ---------- AUTH & INITIALIZATION ----------
function login(){ auth.signInWithPopup(new firebase.auth.GoogleAuthProvider()).catch(e=>alert(e.message)); }
function logout(){ 
    if(unsubscribeMessages) unsubscribeMessages(); 
    if(unsubscribeUnread) unsubscribeUnread(); 
    auth.signOut(); 
}

auth.onAuthStateChanged(async user=>{
    if(!user){ loginPage.classList.remove("hidden"); dashboard.classList.add("hidden"); return; }
    
    loginPage.classList.add("hidden"); dashboard.classList.remove("hidden"); currentUser=user;
    
    const userRef=db.collection("users").doc(user.uid);
    const userDoc = await userRef.get();

    // 1. New User Setup (If profile doesn't exist or is missing new fields)
    if(!userDoc.exists || !userDoc.data().featuredGames){
        const baseName = (user.displayName || user.email.split('@')[0]).replace(/\s/g, '').toLowerCase();
        const defaultUsername = baseName.substring(0, 16).slice(0, 16 - 4) + Math.floor(1000 + Math.random() * 9000); 
        
        // Ensure new fields exist for new and existing users
        const profileUpdate = {
            uid: user.uid,
            username: userDoc.exists ? (userDoc.data().username || defaultUsername) : defaultUsername,
            usernameChanged: userDoc.exists ? (userDoc.data().usernameChanged || false) : false,
            bio: userDoc.exists ? (userDoc.data().bio || "New Cyber Warrior seeking a Duo partner!") : "New Cyber Warrior seeking a Duo partner!",
            skillRating: userDoc.exists ? (userDoc.data().skillRating || 3) : 3,
            status: userDoc.exists ? (userDoc.data().status || "Online") : "Online",
            friends: userDoc.exists ? (userDoc.data().friends || []) : [],
            profileImageUrl: user.photoURL || DEFAULT_AVATAR,
            nickname: user.displayName, 
            gamerCards: userDoc.exists ? (userDoc.data().gamerCards || []) : [],
            featuredGames: userDoc.exists ? (userDoc.data().featuredGames || []) : [], // NEW FIELD
        };
        
        await userRef.set(profileUpdate, { merge: true });

        // Only set username doc if new user
        if (!userDoc.exists) {
            await db.collection("usernames").doc(defaultUsername).set({
                uid: user.uid,
                username: defaultUsername
            });
        }
    }
    
    // 2. Load Core Data
    await loadUserProfile(); 
    await loadRelationshipStatus(); 
    await loadBlocks(); 

    // 3. Load UI Data
    welcome.textContent=`Welcome, ${currentUser.displayName || currentUser.email}`;
    await loadAllUsers(); 
    loadFriendRequests();
    await loadFriends();
    // initMessaging(); // Placeholder
});


// Helper to track sent/received requests
async function loadRelationshipStatus() {
    if (!currentUser) return;
    pendingRequests = {};
    sentRequests = {};

    const incomingSnap = await db.collection("friendRequests")
        .where("receiverId", "==", currentUser.uid)
        .get();
    incomingSnap.forEach(doc => {
        pendingRequests[doc.data().senderId] = doc.id;
    });

    const outgoingSnap = await db.collection("friendRequests")
        .where("senderId", "==", currentUser.uid)
        .get();
    outgoingSnap.forEach(doc => {
        sentRequests[doc.data().receiverId] = doc.id;
    });
}

// Loads UIDs blocked by the current user
async function loadBlocks() {
    if (!currentUser) return;
    blockedUsers = {};
    
    const blocksSnap = await db.collection("blocks")
        .where("blockerId", "==", currentUser.uid) 
        .get();
        
    blocksSnap.forEach(doc => {
        const blockedUid = doc.id.split('_')[1];
        blockedUsers[blockedUid] = doc.id;
    });
}

// Loads user profile data for the editor
async function loadUserProfile() {
    const userDoc = await db.collection("users").doc(currentUser.uid).get();
    currentProfileData = userDoc.data() || {}; 

    profileAvatar.src = currentProfileData.profileImageUrl || DEFAULT_AVATAR;
    
    const currentDisplayUsername = currentProfileData.username || 'Loading...';

    profileNickname.value = currentProfileData.nickname || currentUser.displayName || "Unknown User";
    
    profileBio.value = currentProfileData.bio || "";
    profileSkillRating.value = currentProfileData.skillRating || "3";
    profileStatus.value = currentProfileData.status || "Online";

    document.getElementById("usernameDisplay").textContent = `@${currentDisplayUsername}`;
    
    const changeBtn = document.getElementById("changeUsernameBtn");
    const input = document.getElementById("newUsernameInput");
    const messageElement = document.getElementById("usernameMessage");

    const hasChanged = currentProfileData.usernameChanged === true;
    
    if (hasChanged) {
        changeBtn.textContent = "Changed Once (Locked)";
        changeBtn.disabled = true;
        input.disabled = true;
        messageElement.textContent = "Your unique username has been permanently set.";
    } else {
        changeBtn.textContent = "Set/Change Username";
        changeBtn.disabled = false;
        input.disabled = false;
        messageElement.textContent = "You have one change remaining to set your unique @handle.";
    }
    
    renderGameSlots(); // Render the game slots
}


// --- GAME SLOTS LOGIC ---

function renderGameSlots() {
    const gameSlotList = document.getElementById('gameSlotList');
    const featuredGames = currentProfileData.featuredGames || [];
    gameSlotList.innerHTML = '';
    
    // Update button visibility
    document.getElementById('addGameBtn').disabled = featuredGames.length >= 4;

    featuredGames.forEach((game, index) => {
        const slot = document.createElement('div');
        slot.className = 'game-slot';
        slot.innerHTML = `
            <button class="remove-game-btn" onclick="removeGameSlot(${index})">X</button>
            <h4>Game ${index + 1}</h4>
            <label style="font-size: 0.9em; color: gray;">Game Title:</label>
            <select data-index="${index}" data-field="game" onchange="updateGameRoleOptions(this.value, ${index})">
                <option value="">-- Select Game --</option>
                ${GAMES_LIST.map(g => `<option value="${g.name}" ${g.name === game.game ? 'selected' : ''}>${g.name}</option>`).join('')}
            </select>
            <label style="font-size: 0.9em; color: gray;">Role/Need:</label>
            <select data-index="${index}" data-field="role" class="role-select-${index}">
                ${generateRoleOptions(game.game, game.role)}
            </select>
        `;
        gameSlotList.appendChild(slot);
    });
}

function generateRoleOptions(gameName, selectedRole) {
    const game = GAMES_LIST.find(g => g.name === gameName);
    const roles = game ? game.roles : ["Any"];
    return roles.map(r => `<option value="${r}" ${r === selectedRole ? 'selected' : ''}>${r}</option>`).join('');
}

function updateGameRoleOptions(gameName, index) {
    const select = document.querySelector(`.role-select-${index}`);
    if (select) {
        select.innerHTML = generateRoleOptions(gameName, "");
    }
}

function addGameSlot() {
    if (currentProfileData.featuredGames.length < 4) {
        currentProfileData.featuredGames.push({
            game: GAMES_LIST[0].name, // Default to first game
            role: GAMES_LIST[0].roles[0] // Default to first role
        });
        renderGameSlots();
    } else {
        alert("Maximum of 4 featured games allowed.");
    }
}

function removeGameSlot(index) {
    currentProfileData.featuredGames.splice(index, 1);
    renderGameSlots();
}

async function saveProfile() {
    const featuredGames = [];
    const gameSlots = document.querySelectorAll('#gameSlotList .game-slot');
    let hasError = false;

    gameSlots.forEach((slot, index) => {
        const gameSelect = slot.querySelector(`select[data-field="game"]`);
        const roleSelect = slot.querySelector(`select[data-field="role"]`);
        
        if (gameSelect.value && roleSelect.value) {
            featuredGames.push({
                game: gameSelect.value,
                role: roleSelect.value
            });
        } else if (gameSelect.value || roleSelect.value) {
             hasError = true;
        }
    });
    
    if (hasError) {
        alert("Please ensure every selected game slot has both a Game Title and a Role/Need selected, or remove the slot.");
        return;
    }

    const updateData = {
        bio: profileBio.value,
        skillRating: parseInt(profileSkillRating.value),
        status: profileStatus.value,
        featuredGames: featuredGames, // Save the collected game data
    };
    
    try {
        await db.collection("users").doc(currentUser.uid).update(updateData);
        document.getElementById('saveMessage').textContent = 'Profile saved successfully!';
        setTimeout(() => document.getElementById('saveMessage').textContent = '', 3000);
        await loadUserProfile(); // Reload data to reflect changes
        loadAllUsers();
    } catch(e) {
        document.getElementById('saveMessage').textContent = `Error saving profile: ${e.message}`;
        console.error("Save Profile Error:", e);
    }
}

// --- END GAME SLOTS LOGIC ---


// --- TAB MANAGEMENT ---
function showTab(tab){
    document.querySelectorAll('#allUsersTab, #searchTab, #requestsTab, #friendsTab, #messagingTab, #profileTab, #viewProfileTab').forEach(el => el.classList.add('hidden'));
    
    switch(tab){
      case "allUsers": document.getElementById('allUsersTab').classList.remove("hidden"); loadAllUsers(); break; 
      case "search": document.getElementById('searchTab').classList.remove("hidden"); filterSearchResults(); break; 
      case "requests": document.getElementById('requestsTab').classList.remove("hidden"); loadFriendRequests(); break; 
      case "friends": document.getElementById('friendsTab').classList.remove("hidden"); loadFriends(); break; 
      case "messaging": document.getElementById('messagingTab').classList.remove("hidden"); /* initMessaging(); */ break;
      case "profile": document.getElementById('profileTab').classList.remove("hidden"); loadUserProfile(); break; 
      case "viewProfile": document.getElementById('viewProfileTab').classList.remove("hidden"); break; 
    }
}


// ---------- CORE USER CARD RENDERING (UPDATED) ----------

function renderUserCard(d, data) {
    const nickname = data.nickname || "Unknown Player";
    const username = data.username ? `@${data.username}` : nickname;
    const profileImageUrl = data.profileImageUrl || DEFAULT_AVATAR;
    const skillRating = data.skillRating || 0; 
    const status = data.status || "Offline";
    const statusClass = status.replace(/\s/g, "").toLowerCase(); 
    const firstGamerCard = (data.gamerCards && data.gamerCards.length > 0) ? data.gamerCards[0] : null; 
    
    // Check if the card belongs to the current user
    const isCurrentUser = d.id === currentUser.uid;

    const card = document.createElement("div");
    card.className = "card";
    // Only allow viewing other people's profiles
    if (!isCurrentUser) {
        card.onclick = () => viewUserProfile(d.id); 
    }
    
    // Check if the user is the specific OWNER_UID
    const isOwner = d.id === OWNER_UID;

    let cardContentHTML = `
        <div class="card-content-box">
            <img src="${profileImageUrl}" class="avatar">
            <strong>${username}</strong> ${isOwner ? '<span class="owner-badge-box">OWNER</span>' : ''}
            <span class="skill-rating">${'⭐'.repeat(skillRating)}</span>
            <span class="status-indicator status-${statusClass}">${status}</span>
        </div>`;

    if (firstGamerCard) {
        cardContentHTML += `<img src="${firstGamerCard}" class="card-gamer-preview" alt="Gamer Card Preview">`;
    }
    
    // Display featured games
    const featuredGames = data.featuredGames || [];
    if (featuredGames.length > 0) {
        cardContentHTML += `<div class="card-games">`;
        featuredGames.forEach(g => {
            cardContentHTML += `<span class="game-badge">${g.game} (${g.role})</span>`;
        });
        cardContentHTML += `</div>`;
    }


    card.innerHTML = cardContentHTML;

    let actionBtn = null;
    let statusText = null;
    
    // Only show buttons/status for non-current user cards
    if (!isCurrentUser) {
        if (currentProfileData.friends && currentProfileData.friends.includes(d.id)) {
            statusText = document.createElement("p");
            statusText.style.color = 'lime';
            statusText.textContent = "✅ Duo Partner";
        } else if (pendingRequests[d.id]) {
            statusText = document.createElement("p");
            statusText.style.color = 'yellow';
            statusText.textContent = "❗ Incoming Request";
        } else if (sentRequests[d.id]) {
            statusText = document.createElement("p");
            statusText.style.color = 'orange';
            statusText.textContent = "⏳ Request Sent";
        } else if (!blockedUsers[d.id]) {
            actionBtn = document.createElement("button");
            actionBtn.className = "neon-btn";
            actionBtn.textContent = "Send Duo Request";
            actionBtn.onclick = (e) => { e.stopPropagation(); sendFriendRequest(d.id); };
        }
    }
    
    if (actionBtn) card.appendChild(actionBtn);
    if (statusText && !pendingRequests[d.id]) card.appendChild(statusText); 

    return card;
}


// ---------- USER & SEARCH FUNCTIONS (RESTORED) ----------

async function loadAllUsers(){
    allUsersTab.innerHTML = "<h3>Suggested Players</h3>";
    
    if (allUsersCache.length === 0) {
        try {
            const querySnap=await db.collection("users").get();
            allUsersCache = querySnap.docs.map(d => ({
                id: d.id,
                data: d.data()
            }));
        } catch(e) {
            console.error("Error loading all users:", e);
            allUsersTab.innerHTML += `<p style="color:red;">Error loading players: ${e.message}. Check console for details.</p>`;
            return;
        }
    }

    if (allUsersCache.length === 0) {
           allUsersTab.innerHTML += "<p>No other players found in the database.</p>";
           return;
    }

    allUsersCache.forEach(({id, data})=>{
      if(blockedUsers[id]) return; 
      
      const card = renderUserCard({id}, data); 
      allUsersTab.appendChild(card);
    });
}

function filterSearchResults() {
    const searchResults = document.getElementById('searchResults');
    searchResults.innerHTML = "";
    
    const query = document.getElementById('searchInput').value.toLowerCase();
    const statusFilter = document.getElementById('statusFilter').value;
    const minSkill = parseInt(document.getElementById('skillFilter').value);

    const filtered = allUsersCache.filter(({id, data}) => {
        if (id === currentUser.uid || blockedUsers[id]) return false;

        const bio = (data.bio || '').toLowerCase();
        const nickname = (data.nickname || '').toLowerCase();
        const username = (data.username || '').toLowerCase();

        if (query && !(nickname.includes(query) || bio.includes(query) || username.includes(query))) {
            return false;
        }

        if (statusFilter && data.status !== statusFilter) {
            return false;
        }

        if (minSkill > 0 && (data.skillRating || 0) < minSkill) {
            return false;
        }

        return true;
    });

    if (filtered.length === 0) {
        searchResults.innerHTML = "<p>No players match your search criteria.</p>";
    } else {
        filtered.forEach(({id, data}) => {
            const card = renderUserCard({id}, data);
            searchResults.appendChild(card);
        });
    }
}


async function loadFriends() {
    friendsTab.innerHTML = "<h3>Your Duo Partners</h3><p>Duos functionality omitted for this step.</p>";
}
function initMessaging() {
    // Omitted for brevity
}
async function viewUserProfile(uid) {
    showTab('viewProfile');
    // Placeholder for actual profile view logic
    const userDoc = await db.collection("users").doc(uid).get();
    const data = userDoc.data();
    
    if (!data) {
        document.getElementById('viewProfileContent').innerHTML = `<p style="color:red;">Error: Profile not found.</p>`;
        return;
    }

    const gamesHtml = (data.featuredGames || []).map(g => 
        `<span class="game-badge">${g.game} (${g.role})</span>`
    ).join('');

    const isFriend = currentProfileData.friends.includes(uid);
    const isBlocked = blockedUsers[uid];
    
    // Check if the user is the specific OWNER_UID
    const isOwner = uid === OWNER_UID;
    const ownerBadgeHtml = isOwner ? '<span class="owner-badge-box">OWNER</span>' : '';

    const buttonHtml = `
        <button class="neon-btn remove" onclick="removeFriend('${uid}')" style="display:${isFriend ? 'inline-block' : 'none'};">Remove Duo</button>
        <button class="neon-btn remove" onclick="blockUser('${uid}')" style="border-color:red; box-shadow:0 0 10px red; display:${!isBlocked ? 'inline-block' : 'none'};">Block User</button>
        <button class="neon-btn accept" onclick="unblockUser('${uid}')" style="display:${isBlocked ? 'inline-block' : 'none'};">Unblock User</button>
        <button class="neon-btn" onclick="sendFriendRequest('${uid}')" style="display:${!isFriend && !sentRequests[uid] && !pendingRequests[uid] && !isBlocked ? 'inline-block' : 'none'};">Send Duo Request</button>
        <p style="color:orange; margin-top:10px; display:${sentRequests[uid] ? 'block' : 'none'};">⏳ Request Sent</p>
    `;

    document.getElementById('viewProfileContent').innerHTML = `
        <div style="display:flex; align-items:flex-start; margin-bottom: 20px;">
            <img src="${data.profileImageUrl || DEFAULT_AVATAR}" class="avatar" style="width: 100px; height: 100px; margin-right: 20px;">
            <div>
                <h3 style="margin-top:0;">${data.nickname || 'Unknown'} ${ownerBadgeHtml}</h3>
                <p style="color:cyan; font-size:1.2em;">@${data.username}</p>
                <p class="skill-rating">${'⭐'.repeat(data.skillRating || 0)}</p>
                <p class="status-indicator status-${(data.status || 'Offline').replace(/\s/g, "").toLowerCase()}">${data.status || 'Offline'}</p>
            </div>
        </div>
        
        <p><strong>Bio:</strong> ${data.bio || 'No bio provided.'}</p>
        
        <h4 style="color:cyan; border-top: 1px dashed #333; padding-top: 15px;">Featured Games:</h4>
        <div style="margin-bottom: 20px;">${gamesHtml || 'No featured games.'}</div>
        
        <h4 style="color:cyan;">Gamer Cards:</h4>
        <div class="gamer-card-container">
            ${(data.gamerCards || []).map(cardUrl => `<div class="gamer-card"><img src="${cardUrl}"></div>`).join('')}
        </div>
        
        <div style="margin-top: 20px;">
            ${buttonHtml}
        </div>
    `;
}


// ---------- FRIEND REQUESTS & BLOCKING ACTIONS (RESTORED) ----------

async function sendFriendRequest(toUid){
    if(!currentUser || toUid===currentUser.uid) return alert("Cannot send a request to yourself.");
    
    if (currentProfileData.friends && currentProfileData.friends.includes(toUid)) {
        return alert("You are already Duos with this user.");
    }
    
    if (blockedUsers[toUid]) {
        return alert("You have blocked this user. Unblock them first.");
    }
    
    const reqId = getChatId(currentUser.uid, toUid);
    const reqRef = db.collection("friendRequests").doc(reqId);
    
    try {
        await reqRef.set({
            senderId: currentUser.uid,          
            receiverId: toUid,                
            status: "pending",                
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        alert("Duo Request sent! Waiting for acceptance.");
        
        await loadRelationshipStatus(); 
        loadAllUsers(); 
        filterSearchResults();
        
    } catch(e) {
        alert("Error sending request: " + e.message);
        console.error("Friend Request Send Error:", e);
    }
    loadFriendRequests();
}

async function declineFriend(reqId){   
    try {
        await db.collection("friendRequests").doc(reqId).delete();   
        alert("Request declined.");
    } catch(e) {
        alert("Error declining request: " + e.message);
    }
    await loadRelationshipStatus(); 
    loadFriendRequests();     
    loadAllUsers(); 
}

async function acceptFriendRequest(requestId, senderId) {
    if (!currentUser) return;
    
    if (!confirm(`Are you sure you want to accept this Duo request?`)) {
        return;
    }

    const receiverId = currentUser.uid;
    const requestRef = db.collection("friendRequests").doc(requestId);
    const senderRef = db.collection("users").doc(senderId);
    const receiverRef = db.collection("users").doc(receiverId);

    try {
        await db.runTransaction(async (t) => {
            // 1. Delete the friend request
            t.delete(requestRef);

            // 2. Update Sender's profile (add receiverId to friends array)
            t.update(senderRef, {
                friends: firebase.firestore.FieldValue.arrayUnion(receiverId),
            });

            // 3. Update Receiver's profile (add senderId to friends array)
            t.update(receiverRef, {
                friends: firebase.firestore.FieldValue.arrayUnion(senderId),
            });
        });
        
        alert(`Request accepted! You are now Duos with @${friendUsers[senderId]?.username || senderId}.`);

    } catch (e) {
        alert("Error accepting request. Please try again. " + e.message);
        console.error("Accept Request Transaction Failed:", e);
        return;
    }
    
    // Refresh UI state
    await loadRelationshipStatus(); 
    await loadUserProfile();
    loadFriendRequests();
    loadFriends();
    loadAllUsers();
    showTab('friends');
}

async function loadFriendRequests(){
    requestsTab.innerHTML="<h3>Incoming Requests</h3>";
    const querySnap=await db.collection("friendRequests")
      .where("receiverId","==",currentUser.uid).get();
      
    const requestsData = await Promise.all(querySnap.docs.map(async d => {
        const request = d.data();
        const senderDoc = await db.collection("users").doc(request.senderId).get();
        const senderData = senderDoc.data() || { username: 'Unknown', nickname: 'Unknown User' };
        
        return {
            id: d.id, 
            senderId: request.senderId, 
            display: senderData.username ? `@${senderData.username}` : (senderData.nickname || 'Unknown User'),
            senderProfileImageUrl: senderData.profileImageUrl || DEFAULT_AVATAR
        };
    }));

    if (requestsData.length === 0) {
        requestsTab.innerHTML += "<p>No new Duo requests.</p>";
    }

    requestsData.forEach(r => {
        const div = document.createElement("div");
        div.className = "card";
        div.onclick = () => viewUserProfile(r.senderId); 
        div.innerHTML = `
            <div class="card-content-box">
                <img src="${r.senderProfileImageUrl}" class="avatar">
                <strong>${r.display}</strong> wants to duo!
            </div>`;
        
        const declineBtn = document.createElement("button");
        declineBtn.className = "neon-btn remove";    
        declineBtn.textContent = "Decline";
        declineBtn.onclick = (e) => {    
            e.stopPropagation();    
            declineFriend(r.id);    
        };
        
        const acceptBtn = document.createElement("button");
        acceptBtn.className = "neon-btn accept";
        acceptBtn.textContent = "Accept";
        acceptBtn.onclick = (e) => {    
            e.stopPropagation();    
            acceptFriendRequest(r.id, r.senderId);    
        };

        const buttonGroup = document.createElement("div");
        buttonGroup.style.display = 'flex';
        buttonGroup.style.marginTop = '10px';
        buttonGroup.appendChild(acceptBtn);
        buttonGroup.appendChild(declineBtn);
        
        div.appendChild(buttonGroup);
        requestsTab.appendChild(div);
    });
}

// Additional profile/storage functions restored for completeness:
async function removeFriend(friendUid) {
    if (!currentUser || friendUid === currentUser.uid) return;
    if (!confirm(`Are you sure you want to remove this profile from your Duo list? This will also clear the chat history.`)) {
        return;
    }
    const userRef = db.collection("users").doc(currentUser.uid);
    const friendRef = db.collection("users").doc(friendUid);
    try {
        await db.runTransaction(async (t) => {
            t.update(userRef, {
                friends: firebase.firestore.FieldValue.arrayRemove(friendUid),
            });
            t.update(friendRef, {
                friends: firebase.firestore.FieldValue.arrayRemove(currentUser.uid),
            });
        });
        alert(`Successfully removed Duo.`);
    } catch (e) {
        alert("Error removing Duo: " + e.message);
        console.error("Friend removal transaction failed:", e);
    }
    await loadRelationshipStatus(); 
    loadFriends();
    loadUserProfile();
    loadAllUsers(); 
    showTab('friends'); 
}
async function blockUser(targetUid) {
    if (!currentUser || targetUid === currentUser.uid) return;
    if (!confirm(`Are you sure you want to block this user? This will stop them from messaging you.`)) {
        return;
    }
    const blockId = `${currentUser.uid}_${targetUid}`; 
    const blockRef = db.collection("blocks").doc(blockId);
    try {
        await blockRef.set({
            blockerId: currentUser.uid,
            blockedId: targetUid,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        alert(`User @${friendUsers[targetUid]?.username || targetUid} has been blocked.`);
    } catch (e) {
        alert("Error blocking user: " + e.message);
        console.error("Block User Error:", e);
    }
    await loadBlocks(); 
    await loadAllUsers();
    viewUserProfile(targetUid);
}
async function unblockUser(targetUid) {
    if (!currentUser || targetUid === currentUser.uid) return;
    if (!confirm(`Are you sure you want to UNBLOCK this user? They will be able to message you again.`)) {
        return;
    }
    const blockId = blockedUsers[targetUid];
    try {
        if (blockId) {
            await db.collection("blocks").doc(blockId).delete();
            alert(`User @${friendUsers[targetUid]?.username || targetUid} has been unblocked.`);
        } else {
            alert("Error: Block record not found.");
        }
    } catch (e) {
        alert("Error unblocking user: " + e.message);
        console.error("Unblock User Error:", e);
    }
    await loadBlocks(); 
    await loadAllUsers(); 
    viewUserProfile(targetUid);
}
// Placeholder for other missing functions:
function previewAvatar(input) { console.log('Preview avatar functionality not implemented.'); }
function attemptUsernameChange() { console.log('Username change functionality not implemented.'); }
function renderGamerCards() { console.log('Gamer card functionality not implemented.'); }
</script>

</body>
</html>
