<script>
// ------------------------------------------------
// 1. FIREBASE INIT AND CONSTANTS
// ------------------------------------------------
const firebaseConfig = {
    // !! IMPORTANT: REPLACE WITH YOUR OWN FIREBASE CONFIG !!
    apiKey: "AIzaSyDVHxatohLvJNqIHXjf1ZXdmmWX5W1EpNw",
    authDomain: "duoup-cfae6.firebaseapp.com",
    projectId: "duoup-cfae6",
    storageBucket: "duoup-cfae6.firebasestorage.app",
    messagingSenderId: "812263060524",
    appId: "1:812263060524:web:ac09c3ae610db1cd110d89",
    measurementId: "G-46B67F90FK"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
const storage = firebase.storage();

const DEFAULT_AVATAR = "https://cdn-icons-png.flaticon.com/512/149/149071.png";

// ------------------------------------------------
// 2. GLOBAL STATE VARIABLES
// ------------------------------------------------
let currentUser = null;
let currentProfileData = {}; 
let allUsersCache = [];    
let friendProfiles = {}; 
let outgoingRequestsCache = {}; 

// Messaging Specific State
let currentChatUid = null;
let chatListener = null; // Stores the Firestore unsubscribe function for the active chat

// ------------------------------------------------
// 3. CORE HELPER FUNCTIONS
// ------------------------------------------------

// --- AUTHENTICATION FUNCTIONS ---
function login(){ auth.signInWithPopup(new firebase.auth.GoogleAuthProvider()).catch(e=>alert(e.message)); }
function logout(){ 
    if(chatListener) chatListener(); // Stop listening to the current chat
    auth.signOut(); 
}

// --- TAB MANAGEMENT ---
function showTab(tab){
    document.querySelectorAll('#allUsersTab, #searchTab, #friendsTab, #messagingTab, #profileTab, #viewProfileTab').forEach(el => el.classList.add('hidden'));
    
    // Stop the chat listener when navigating away from the messaging tab
    if (tab !== 'messaging' && chatListener) {
        chatListener();
        chatListener = null;
        currentChatUid = null;
    }

    switch(tab){
      case "allUsers": document.getElementById('allUsersTab').classList.remove("hidden"); loadAllUsers(); break; 
      case "search": document.getElementById('searchTab').classList.remove("hidden"); filterSearchResults(); break; 
      case "friends": document.getElementById('friendsTab').classList.remove("hidden"); loadFriends(); break; 
      case "messaging": document.getElementById('messagingTab').classList.remove("hidden"); loadChatList(); break; 
      case "profile": document.getElementById('profileTab').classList.remove("hidden"); loadUserProfile(); break; 
      case "viewProfile": document.getElementById('viewProfileTab').classList.remove("hidden"); break; 
    }
}

// --- PROFILE LOADING ---
async function loadUserProfile() {
    if (!currentUser) return;
    const userDoc = await db.collection("users").doc(currentUser.uid).get();
    currentProfileData = userDoc.data() || {}; 

    const currentDisplayUsername = currentProfileData.username || 'Loading...';

    // Update Profile Tab UI
    document.getElementById("profileAvatar").src = currentProfileData.profileImageUrl || DEFAULT_AVATAR;
    document.getElementById("profileNickname").value = currentProfileData.nickname || currentUser.displayName || "Unknown User";
    document.getElementById("profileBio").value = currentProfileData.bio || "";
    document.getElementById("profileSkillRating").value = String(currentProfileData.skillRating || "3");
    document.getElementById("profileStatus").value = currentProfileData.status || "Online";
    document.getElementById("usernameDisplay").textContent = `@${currentDisplayUsername}`;
    
    const changeBtn = document.getElementById("changeUsernameBtn");
    const input = document.getElementById("newUsernameInput");
    const messageElement = document.getElementById("usernameMessage");

    const hasChanged = currentProfileData.usernameChanged === true;
    
    if (hasChanged) {
        changeBtn.textContent = "Changed Once (Locked)";
        changeBtn.disabled = true;
        input.disabled = true;
        messageElement.textContent = `Your unique username (@${currentProfileData.username}) has been permanently set.`;
        messageElement.style.color = 'lime';
    } else {
        changeBtn.textContent = "Set/Change Username";
        changeBtn.disabled = false;
        input.disabled = false;
        messageElement.textContent = "You have one change remaining to set your unique @handle.";
        messageElement.style.color = 'yellow';
    }
}

// --- PROFILE SAVE FUNCTION ---
async function saveProfile() {
    if (!currentUser) return;

    const bio = document.getElementById("profileBio").value.trim();
    const skillRating = parseInt(document.getElementById("profileSkillRating").value);
    const status = document.getElementById("profileStatus").value;
    
    const saveMessageElement = document.getElementById("saveMessage");
    saveMessageElement.textContent = "Saving profile...";
    saveMessageElement.style.color = 'yellow';

    try {
        await db.collection("users").doc(currentUser.uid).update({
            bio: bio,
            skillRating: skillRating,
            status: status
        });

        saveMessageElement.textContent = "Profile Saved Successfully! Reloading...";
        saveMessageElement.style.color = '#00ff00';
        
        await loadUserProfile(); 
        await loadAllUsers(); 
        setTimeout(() => {
            saveMessageElement.textContent = "";
        }, 3000);

    } catch (e) {
        console.error("Profile Save Error:", e);
        saveMessageElement.textContent = `Save Failed: ${e.message}. Check your rules!`;
        saveMessageElement.style.color = 'red';
    }
}


// --- USERNAME CHANGE FUNCTION ---
async function attemptUsernameChange() {
    if (!currentUser || currentProfileData.usernameChanged) return;

    const input = document.getElementById("newUsernameInput");
    const newUsername = input.value.trim().toLowerCase();
    const messageElement = document.getElementById("usernameMessage");
    
    if (newUsername.length < 3 || newUsername.length > 20 || !/^[a-z0-9]+$/.test(newUsername)) {
        messageElement.textContent = "Username must be 3-20 lowercase letters/numbers.";
        messageElement.style.color = 'red';
        return;
    }

    messageElement.textContent = "Checking availability...";
    messageElement.style.color = 'yellow';

    try {
        const usernameDoc = await db.collection("usernames").doc(newUsername).get();
        if (usernameDoc.exists) {
            messageElement.textContent = `@${newUsername} is already taken. Try another.`;
            messageElement.style.color = 'red';
            return;
        }

        // Use transaction for atomic username swap
        await db.runTransaction(async (transaction) => {
            const userRef = db.collection("users").doc(currentUser.uid);
            
            // a. Update the main user document
            transaction.update(userRef, {
                username: newUsername,
                usernameChanged: true 
            });

            // b. Create the new reservation
            transaction.set(db.collection("usernames").doc(newUsername), {
                uid: currentUser.uid,
                username: newUsername
            });
            
            // c. Delete the OLD username document
            const oldUsername = currentProfileData.username;
            if (oldUsername && oldUsername !== newUsername) {
                const oldUsernameRef = db.collection("usernames").doc(oldUsername);
                transaction.delete(oldUsernameRef);
            }
        });

        messageElement.textContent = `Success! Your unique handle is now @${newUsername}.`;
        messageElement.style.color = 'lime';
        await loadUserProfile(); 

    } catch (e) {
        console.error("Username Change Error:", e);
        messageElement.textContent = `Error changing username: ${e.message}`;
        messageElement.style.color = 'red';
    }
}


// --- REQUEST STATUS CHECK ---
async function checkIfRequestSent(targetUid) {
    if (!currentUser) return false;
    const requestId = `${currentUser.uid}_${targetUid}`;
    
    // Check local cache first
    if (outgoingRequestsCache[targetUid] === true) {
        return true;
    }
    
    try {
        const doc = await db.collection("requests").doc(requestId).get();
        if (doc.exists) {
            outgoingRequestsCache[targetUid] = true; // Update cache
            return true;
        }
        return false;
    } catch (e) {
        console.error("Error checking request status:", e);
        return false;
    }
}


// --- USER LIST LOADING ---
async function loadAllUsers(){
    const allUsersTab = document.getElementById('allUsersTab');
    allUsersTab.innerHTML = "<h3>Suggested Players</h3>";
    if (!currentUser) {
        allUsersTab.innerHTML += "<p style='color:yellow;'>Please log in to see suggested players.</p>";
        return;
    }
    try {
        const snapshot = await db.collection("users").get(); 
        
        allUsersCache = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        // Efficiently check for OUTGOING requests using a query.
        const outgoingSnapshot = await db.collection("requests")
            .where("senderId", "==", currentUser.uid)
            .where("status", "==", "pending")
            .get();
        
        // Clear and rebuild the cache based on the fetch
        outgoingRequestsCache = {};
        outgoingSnapshot.forEach(doc => {
            outgoingRequestsCache[doc.data().receiverId] = true;
        });

        // Render all cards using the cache
        allUsersCache.forEach(user => {
            if (user.id !== currentUser.uid) { 
                const isRequestSent = outgoingRequestsCache[user.id] === true;
                // Calls the defined function below
                allUsersTab.appendChild(renderUserCard({ uid: user.id }, user, isRequestSent));
            }
        });

        if (allUsersTab.children.length <= 1) { 
             allUsersTab.innerHTML += "<p>No other users found in the system.</p>";
        }

    } catch(e) {
        allUsersTab.innerHTML += `<p style="color:red; font-weight:bold;">Error loading users: ${e.message}</p>`;
        console.error("Load All Users Error:", e);
    }
}

// --- SEARCH AND FILTERING FUNCTION ---
function filterSearchResults() {
    const searchInput = document.getElementById('searchInput').value.toLowerCase();
    const statusFilter = document.getElementById('statusFilter').value;
    const skillFilter = parseInt(document.getElementById('skillFilter').value); 
    const searchResultsDiv = document.getElementById('searchResults');
    searchResultsDiv.innerHTML = ""; 

    const filteredUsers = allUsersCache.filter(user => {
        if (user.id === currentUser.uid) return false;

        const userNickname = (user.nickname || "").toLowerCase();
        const userUsername = (user.username || "").toLowerCase();
        const userBio = (user.bio || "").toLowerCase();
        
        const textMatch = userNickname.includes(searchInput) || userUsername.includes(searchInput) || userBio.includes(searchInput);
        if (!textMatch) return false;

        if (statusFilter && user.status !== statusFilter) return false;

        const userSkill = user.skillRating || 0; 
        if (userSkill < skillFilter) return false;

        return true;
    });

    if (filteredUsers.length === 0) {
        searchResultsDiv.innerHTML = "<p>No players matched your current filter criteria.</p>";
        return;
    }

    filteredUsers.forEach(user => {
        const isRequestSent = outgoingRequestsCache[user.id] === true;
        searchResultsDiv.appendChild(renderUserCard({ uid: user.id }, user, isRequestSent));
    });
}


// --- FRIEND/REQUEST LOADING (DUOS TAB) ---
async function loadFriends() {
    const friendsTab = document.getElementById('friendsTab');
    friendsTab.innerHTML = ""; 
    friendProfiles = {}; 
    const friendUids = Array.isArray(currentProfileData.friends) ? currentProfileData.friends : [];
    
    let incomingRequests = [];
    
    try {
        // 1. FETCH INCOMING REQUESTS
        const requestsSnapshot = await db.collection("requests")
            .where("receiverId", "==", currentUser.uid)
            .where("status", "==", "pending")
            .get();
            
        requestsSnapshot.forEach(doc => {
            const data = doc.data();
            incomingRequests.push({ 
                requestId: doc.id, 
                senderId: data.senderId,
                sentAt: data.sentAt
            });
        });
        
    } catch(e) {
        console.error("Error loading incoming requests:", e);
        friendsTab.innerHTML += `<p style="color:red;">Error fetching requests. Check /requests READ rule: ${e.message}</p>`;
    }
    
    // --- 2. DISPLAY INCOMING REQUESTS ---
    if (incomingRequests.length > 0) {
        friendsTab.innerHTML += `<h3>Pending Requests (${incomingRequests.length})</h3><div class="card-container" id="pendingRequestsContainer"></div>`;
        const requestContainer = friendsTab.querySelector('#pendingRequestsContainer');
        
        const senderPromises = incomingRequests.map(req => db.collection("users").doc(req.senderId).get());
        const senderDocs = await Promise.all(senderPromises);

        senderDocs.forEach((doc, index) => {
            if (!doc.exists) return;
            const senderData = doc.data();
            const senderUid = doc.id;
            const requestId = incomingRequests[index].requestId;
            
            requestContainer.appendChild(renderRequestCard({ uid: senderUid }, senderData, requestId));
        });
    } else {
        friendsTab.innerHTML += `<p style="color:gray;">No pending requests at this time.</p>`;
    }

    // --- 3. DISPLAY ESTABLISHED DUOS ---
    friendsTab.innerHTML += "<h3 style='margin-top:20px;'>Established Duos</h3><div class='card-container' id='establishedDuosContainer'></div>";
    const duoContainer = friendsTab.querySelector('#establishedDuosContainer');

    if (friendUids.length === 0) {
        duoContainer.innerHTML = "<p>You have no Duo Partners yet. Find someone in Suggested or Search!</p>";
    }
    
    const friendPromises = friendUids.map(uid => db.collection("users").doc(uid).get());
    const friendDocs = await Promise.all(friendPromises);

    friendDocs.forEach(doc => {
        if (!doc.exists) return;
        const friendData = doc.data();
        friendProfiles[doc.id] = friendData;
        // isRequestSent is not relevant for established duos, pass false
        duoContainer.appendChild(renderUserCard(doc, friendData, false)); 
    });
    
    if (!document.getElementById('messagingTab').classList.contains('hidden')) {
        loadChatList();
    }
}


// ------------------------------------------------
// 4. RENDERING FUNCTIONS (Fixes "renderUserCard is not defined")
// ------------------------------------------------

/**
 * Renders a card for an INCOMING friend request.
 */
function renderRequestCard(d, data, requestId) {
    const card = document.createElement('div');
    card.className = 'card';
    card.style.borderColor = 'yellow';
    card.style.boxShadow = '0 0 15px rgba(255, 255, 0, 0.6), inset 0 0 5px rgba(255, 255, 0, 0.4)';
    card.style.cursor = 'default';
    
    const statusClass = (data.status || 'Online').replace(/\s/g, '').toLowerCase();
    
    let primaryName = data.nickname || (data.email ? data.email.split('@')[0] : 'Unknown User');
    const displayName = data.username ? `@${data.username}` : primaryName;

    card.innerHTML = `
        <div class="card-content-box" style="border-bottom: 2px solid yellow;">
            <p style="color:yellow; font-weight:bold; margin: 0 0 10px 0;">INCOMING REQUEST</p>
            <img src="${data.profileImageUrl || DEFAULT_AVATAR}" class="avatar" style="border-color: yellow;">
            <h3 style="margin:0; font-size:1.2em;">${displayName}</h3>
            <div class="status-indicator status-${statusClass}">${data.status || 'Online'}</div>
            <p style="margin:5px 0; font-size:0.9em; text-align:center; color:#ccc;">${data.bio || 'No bio provided.'}</p>
        </div>
        <div style="margin-top: 10px;">
            <button class="neon-btn add" style="border-color:lime; box-shadow:0 0 10px lime;" onclick="acceptFriendRequest('${d.uid}', '${requestId}')">Accept Duo</button>
            <button class="neon-btn remove" style="border-color:red; box-shadow:0 0 10px red;" onclick="declineFriendRequest('${requestId}')">Decline</button>
        </div>
    `;

    return card;
}


/**
 * Renders a standard user profile card for discovery, search, or friends list.
 */
function renderUserCard(d, data, isRequestSent) {
    const card = document.createElement('div');
    card.dataset.uid = d.uid; 
    card.className = 'card';
    
    let actionButton = '';
    const isFriend = Array.isArray(currentProfileData.friends) && currentProfileData.friends.includes(d.uid);
    const isSelf = d.uid === currentUser.uid;

    if (isSelf) {
        actionButton = `<span class="owner-badge-box">You</span>`;
    } else if (isFriend) {
        actionButton = `<button class="neon-btn remove" onclick="event.stopPropagation(); removeFriend('${d.uid}')">Remove Duo</button>`;
    } else if (isRequestSent) {
        actionButton = `<button class="neon-btn pending" disabled>Request Sent</button>`;
    } else {
        actionButton = `<button class="neon-btn add" onclick="event.stopPropagation(); sendFriendRequest('${d.uid}')">Send Request</button>`;
    }

    let gameBadges = '';
    (data.featuredGames || []).slice(0, 3).forEach(g => {
        if (typeof g === 'object' && g !== null && g.game) {
            gameBadges += `<span class="game-badge">${g.game} (${g.role || 'Any'})</span>`;
        }
    });

    const statusClass = (data.status || 'Online').replace(/\s/g, '').toLowerCase();
    let primaryName = data.nickname || (data.email ? data.email.split('@')[0] : 'Unknown User');
    const displayName = data.username ? `@${data.username}` : primaryName;

    card.innerHTML = `
        <div class="card-content-box">
            <img src="${data.profileImageUrl || DEFAULT_AVATAR}" class="avatar">
            <h3 style="margin:0; font-size:1.2em;">${displayName}</h3>
            <div class="skill-rating">${'⭐'.repeat(data.skillRating || 3)}</div>
            <div class="status-indicator status-${statusClass}">${data.status || 'Online'}</div>
            <p style="margin:5px 0; font-size:0.9em; text-align:center; color:#ccc;">${data.bio || 'No bio provided.'}</p>
        </div>
        <div style="margin-bottom: 10px;">${actionButton}</div>
        <div class="card-games">${gameBadges || '<p style="color:gray;">No games featured.</p>'}</div>
    `;

    return card;
}

// ------------------------------------------------
// 5. FRIEND REQUEST FUNCTIONS
// ------------------------------------------------

async function sendFriendRequest(targetUid) {
    if (!currentUser) return;

    const senderUid = currentUser.uid;
    const receiverUid = targetUid;
    const requestId = `${senderUid}_${receiverUid}`;
    const reverseRequestId = `${receiverUid}_${senderUid}`;

    try {
        const requestRef = db.collection("requests").doc(requestId);
        const reverseRef = db.collection("requests").doc(reverseRequestId);

        // 1. Check for request from this user (A->B)
        const existing = await requestRef.get();
        if (existing.exists) {
            alert("Request already sent.");
            return;
        }

        // 2. Check for reverse request (B->A) -> Auto-accept
        const reverse = await reverseRef.get();
        if (reverse.exists) {
            await acceptFriendRequest(receiverUid, reverse.id);
            alert("Duo request found — automatically accepted!");
            return;
        }

        // 3. Create request
        await requestRef.set({
            senderId: senderUid,
            receiverId: receiverUid,
            status: "pending",
            sentAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        alert("Duo request sent!");
        
        // --- CRITICAL UI UPDATE ---
        outgoingRequestsCache[targetUid] = true;
        
        if (!document.getElementById('allUsersTab').classList.contains('hidden')) {
            loadAllUsers();
        } else if (!document.getElementById('searchTab').classList.contains('hidden')) {
            filterSearchResults();
        }
        // --- END CRITICAL UI UPDATE ---

    } catch (e) {
        console.error("Send Friend Request FAILED:", e);
        alert("CRITICAL FIREBASE ERROR: Failed to send request. Check published Security Rules AND ensure you are on a secure (HTTPS) host.");
    }
}

async function acceptFriendRequest(targetUid, requestId) {
    if (!currentUser) return;
    
    try {
        const batch = db.batch();
        const userRef = db.collection("users").doc(currentUser.uid);
        const targetRef = db.collection("users").doc(targetUid);
        const requestRef = db.collection("requests").doc(requestId);

        batch.update(userRef, { friends: firebase.firestore.FieldValue.arrayUnion(targetUid) });
        batch.update(targetRef, { friends: firebase.firestore.FieldValue.arrayUnion(currentUser.uid) });
        batch.delete(requestRef);

        await batch.commit();

        alert(`Successfully added ${targetUid.substring(0, 8)}... as a Duo partner!`);
        
        delete outgoingRequestsCache[targetUid];
        await loadUserProfile(); 
        await loadFriends(); 
        loadAllUsers(); 
        filterSearchResults();

    } catch (e) {
        console.error("Accept Request Error:", e);
        alert("Failed to accept request: " + (e.message || "Check Security Rules."));
    }
}

async function declineFriendRequest(requestId) {
    if (!currentUser) return;
    
    try {
        await db.collection("requests").doc(requestId).delete();
        
        alert("Duo request declined.");
        await loadFriends(); 

    } catch (e) {
        console.error("Decline Request Error:", e);
        alert("Failed to decline request: " + (e.message || "Check Security Rules."));
    }
}

async function removeFriend(friendId) {
    if (!currentUser) return;
    try {
        await db.collection("users").doc(currentUser.uid).update({
            friends: firebase.firestore.FieldValue.arrayRemove(friendId)
        });
        
        await db.collection("users").doc(friendId).update({ friends: firebase.firestore.FieldValue.arrayRemove(currentUser.uid) });

        alert(`Successfully removed ${friendId.substring(0, 8)}... from Duos.`);
        await loadUserProfile(); 
        await loadFriends();
        loadAllUsers(); 
        filterSearchResults();
    } catch (e) {
        console.error("Remove Friend Error:", e);
        alert("Remove Duo Failed: " + (e.message || "Check Security Rules."));
    }
}


// ------------------------------------------------
// 6. MESSAGING IMPLEMENTATION
// ------------------------------------------------

// IMPORTANT: Creates a consistent ID for the chat document by sorting the UIDs
function getCanonicalChatId(uid1, uid2) {
    const participants = [uid1, uid2].sort();
    return participants.join('_');
}

/**
 * Loads and displays the list of chatable duos.
 */
function loadChatList() {
    const activeDuoList = document.getElementById('activeDuoList');
    activeDuoList.innerHTML = '';
    
    const friendUids = currentProfileData.friends || [];
    
    if (friendUids.length === 0) {
        activeDuoList.innerHTML = '<p style="color:yellow; font-size:0.9em;">No Duos found. Go to the "Duos" tab to add a partner!</p>';
        return;
    }

    friendUids.forEach(friendUid => {
        const friend = friendProfiles[friendUid];
        if (!friend) return; 

        const entry = document.createElement('div');
        entry.className = 'chat-entry';
        entry.dataset.uid = friendUid;
        entry.onclick = () => startChat(friendUid);
        
        const displayName = friend.username ? `@${friend.username}` : friend.nickname;

        entry.innerHTML = `
            <div style="display:flex; align-items:center;">
                <img src="${friend.profileImageUrl || DEFAULT_AVATAR}" class="avatar" style="width:30px; height:30px; margin-right:10px; border-color: cyan;">
                <span style="flex-grow:1;">${displayName}</span>
            </div>
        `;
        activeDuoList.appendChild(entry);
    });
}

/**
 * Starts a real-time listener for a specific chat.
 */
function startChat(targetUid) {
    if (!currentUser) return;

    // 1. Stop any existing listener
    if (chatListener) {
        chatListener();
    }

    // 2. Update UI to reflect active chat
    currentChatUid = targetUid;
    const friend = friendProfiles[targetUid];
    const friendName = friend.username ? `@${friend.username}` : friend.nickname;
    
    document.getElementById('chatHeader').textContent = `Chatting with ${friendName}`;
    document.getElementById('messageDisplay').innerHTML = 'Loading messages...';
    document.getElementById('messageInputArea').classList.remove('hidden');

    document.querySelectorAll('.chat-entry').forEach(el => el.classList.remove('active'));
    document.querySelector(`.chat-entry[data-uid="${targetUid}"]`).classList.add('active');


    // 3. Set up the new real-time listener
    const chatId = getCanonicalChatId(currentUser.uid, targetUid);
    const chatRef = db.collection('messages').doc(chatId).collection('history').orderBy('timestamp', 'asc');

    chatListener = chatRef.onSnapshot(snapshot => {
        const messageDisplay = document.getElementById('messageDisplay');
        messageDisplay.innerHTML = ''; // Clear display

        snapshot.forEach(doc => {
            const data = doc.data();
            const messageEl = document.createElement('div');
            
            // Determine if the message was sent or received
            const isSent = data.senderId === currentUser.uid;
            messageEl.className = `message ${isSent ? 'sent' : 'received'}`;
            
            // Format time (optional, simplified here)
            const time = data.timestamp ? new Date(data.timestamp.toDate()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '...';
            
            messageEl.innerHTML = `
                <p style="margin:0; font-weight:bold; font-size: 0.8em; color: ${isSent ? 'lime' : 'yellow'};">${isSent ? 'You' : friendName}</p>
                <p style="margin:0;">${data.text}</p>
                <span style="font-size:0.6em; color:#888; display:block; text-align:${isSent ? 'right' : 'left'};">${time}</span>
            `;
            
            messageDisplay.appendChild(messageEl);
        });

        // Scroll to the bottom on every update
        messageDisplay.scrollTop = messageDisplay.scrollHeight;

    }, error => {
        console.error("Chat Listener Error:", error);
        document.getElementById('messageDisplay').innerHTML = `<p style="color:red;">Error loading chat: ${error.message}</p>`;
    });
}

/**
 * Sends a new message to the active chat.
 */
async function sendMessage() {
    if (!currentUser || !currentChatUid) return;

    const input = document.getElementById('messageInput');
    const messageText = input.value.trim();

    if (messageText.length === 0) return;

    const chatId = getCanonicalChatId(currentUser.uid, currentChatUid);

    try {
        await db.collection('messages').doc(chatId).collection('history').add({
            senderId: currentUser.uid,
            receiverId: currentChatUid,
            text: messageText,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });

        input.value = ''; // Clear the input field
        input.focus();
        
    } catch (e) {
        console.error("Send Message Failed:", e);
        alert("Failed to send message. Check Firestore rules for /messages and your network connection.");
    }
}


// ------------------------------------------------
// 7. USER DATA REPAIR FUNCTION (Needed for smooth login)
// ------------------------------------------------
async function ensureUserProfileDefaults(user) {
    const userRef = db.collection("users").doc(user.uid);
    const userDoc = await userRef.get();
    
    const defaults = {
        nickname: user.displayName || user.email.split('@')[0], 
        bio: "New Cyber Warrior seeking a Duo partner!",
        skillRating: 3,
        status: "Online",
        profileImageUrl: user.photoURL || DEFAULT_AVATAR,
        friends: [],
        gamerCards: [],
        featuredGames: [],
        usernameChanged: false,
    };
    
    const existingData = userDoc.data() || {};
    let updateData = {};
    let needsUpdate = false;

    for (const key in defaults) {
        if (existingData[key] === undefined || existingData[key] === null || 
            (key === 'friends' && !Array.isArray(existingData[key])) ||
            (key === 'gamerCards' && !Array.isArray(existingData[key])) ||
            (key === 'featuredGames' && !Array.isArray(existingData[key])) ||
            (key === 'skillRating' && typeof existingData[key] !== 'number')) 
        {
            updateData[key] = defaults[key];
            needsUpdate = true;
        }
    }
    
    if (existingData.username === undefined || existingData.username === null || existingData.username === "") {
        const baseName = (user.displayName || user.email.split('@')[0]).replace(/\s/g, '').toLowerCase();
        const randomSuffix = Math.floor(1000 + Math.random() * 9000); 
        const defaultUsername = baseName.substring(0, 16).replace(/[^a-z0-9]/g, '').slice(0, 16 - 4) + randomSuffix; 
        
        updateData.username = defaultUsername;
        needsUpdate = true;
        
        try {
             await db.collection("usernames").doc(defaultUsername).set({
                uid: user.uid,
                username: defaultUsername
            }, { merge: true }); 
        } catch(e) {
            console.warn("Could not set username reservation during repair:", e);
        }
    }

    if (needsUpdate) {
        console.log("Repairing missing user profile fields for:", user.uid, updateData);
        await userRef.set(updateData, { merge: true });
    }
}


// ------------------------------------------------
// 8. MAIN EXECUTION BLOCK 
// ------------------------------------------------

auth.onAuthStateChanged(async user=>{
    if(!user){ 
        document.getElementById("loginPage").classList.remove("hidden"); 
        document.getElementById("dashboard").classList.add("hidden"); 
        return; 
    }
    
    document.getElementById("loginPage").classList.add("hidden"); 
    document.getElementById("dashboard").classList.remove("hidden"); 
    currentUser=user;
    
    const userRef=db.collection("users").doc(user.uid);
    const userDoc = await userRef.get();

    // 1. Initial User Setup or Data Repair
    if(!userDoc.exists){
        const baseName = (user.displayName || user.email.split('@')[0]).replace(/\s/g, '').toLowerCase();
        const randomSuffix = Math.floor(1000 + Math.random() * 9000); 
        const defaultUsername = baseName.substring(0, 16).replace(/[^a-z0-9]/g, '').slice(0, 16 - 4) + randomSuffix; 
        
        const profileUpdate = {
            uid: user.uid,
            username: defaultUsername,
            usernameChanged: false, 
            bio: "New Cyber Warrior seeking a Duo partner!", 
            skillRating: 3, 
            status: "Online", 
            friends: [], 
            profileImageUrl: user.photoURL || DEFAULT_AVATAR, 
            nickname: user.displayName, 
            gamerCards: [], 
            featuredGames: [], 
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        await userRef.set(profileUpdate);
        await db.collection("usernames").doc(defaultUsername).set({
            uid: user.uid,
            username: defaultUsername
        });
        
    } else {
        await ensureUserProfileDefaults(user);
    }
    
    // 2. Load Core Data
    await loadUserProfile(); 

    // 3. Load UI Data
    document.getElementById("welcome").textContent=`Welcome, ${currentProfileData.nickname || currentUser.displayName || currentUser.email}`;
    await loadAllUsers(); 
    await loadFriends();
    showTab('allUsers'); 
});


// --- OTHER PLACEHOLDERS (Keep these for future expansion) ---
function previewAvatar(input) { console.log("Avatar preview placeholder called."); }
function addGameSlot() { console.log("Add Game Slot placeholder called."); }
</script>
