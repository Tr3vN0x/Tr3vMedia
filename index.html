<?php
// index.php
// This PHP file serves as the wrapper for the single-page application (SPA).
?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DUO UP</title>

<link rel="icon" type="image/x-icon" href="https://your-domain.com/favicon.ico"> 
<link rel="apple-touch-icon" href="https://your-domain.com/apple-touch-icon.png">

<meta property="og:title" content="DUO UP (BETA)">
<meta property="og:description" content="DUO UP IS A WEBSITE WHERE PLAYERS CAN FIND OTHER PLAYERS TO TEAM UP AND DUO CLICK THE LINK TO FIND YOUR TEAMMATE.">
<meta property="og:image" content="https://scontent-iad3-2.xx.fbcdn.net/v/t39.30808-6/598884570_845641984737502_3175907977751628974_n.jpg?_nc_cat=100&ccb=1-7&_nc_sid=127cfc&_nc_ohc=ZuwpdBTHlbQQ7kNvwFLa4-J&_nc_oc=AdnsRNEZ9LGhbLpRqeQnLeM5ZTiGo3THde7Ovkn1ymRwx86CnpNR8dGLxw8Vn8khnNbRizxoPDAEcuzexnVRQJ5Y&_nc_zt=23&_nc_ht=scontent-iad3-2.xx&_nc_gid=3wKM0Dsce2XSdse-2Nk3rw&oh=00_AflRQGBb5NxeRDBjPunJ3xstGrvtMITHymVjwLLf8QvciA&oe=6946C99E">
<meta property="og:url" content="https://tr3vn0x.github.io/DUOUP/">
<meta property="og:type" content="website">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="DUO UP: (BETA)">
<meta name="twitter:description" content="Connect, duo up, and conquer. Find your next teammate today.">
<meta name="twitter:image" content="https://your-domain.com/duo-up-thumbnail.png">

<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-storage-compat.js"></script>

<style>
/* --- Base styles --- */
body { margin:0; font-family:'Orbitron',sans-serif; background:#0b0b0b; color:white; }
.container { width:90%; max-width:1000px; margin:auto; padding:20px; }
.hidden { display:none !important; }

/* --- Header & Welcome Text (Updated for Welcome Message) --- */
.header { background:#111; border-bottom:3px solid cyan; box-shadow:0 0 20px rgba(0,255,255,0.5); padding:10px 0; margin-bottom:20px; display:flex; flex-direction:column; align-items:center; justify-content:center; }
.header-top { display:flex; align-items:center; justify-content:center; width: 100%; }
.header h1 { font-size:2.5em; color:#fff; text-shadow:0 0 5px cyan,0 0 10px cyan,0 0 15px magenta; margin:0; }
.icon-container { margin-right:15px; font-size:2.5em; color:yellow; text-shadow:0 0 5px yellow,0 0 10px orange; }
/* Style for the dynamic Welcome message */
.welcome-text { 
    font-size:1em; 
    color:lime; 
    text-align:center; 
    margin-top: 5px; 
    text-shadow:0 0 5px lime; 
}

/* --- Buttons --- */
.neon-btn { border:2px solid cyan; background:transparent; color:white; padding:8px 14px; margin:5px; border-radius:6px; cursor:pointer; box-shadow:0 0 10px cyan; transition:all 0.2s ease-in-out; text-transform:uppercase; font-family:'Orbitron',sans-serif; }
.neon-btn:hover { border-color:magenta; box-shadow:0 0 15px magenta; transform: translateY(-1px); }
.neon-btn:disabled { border-color:#555; box-shadow:none; color:#555; cursor:not-allowed; }
.neon-btn.add { border-color:lime; box-shadow:0 0 10px lime; }
.neon-btn.add:hover { border-color:green; box-shadow:0 0 15px green; }
.neon-btn.remove { border-color:red; box-shadow:0 0 10px red; }
.neon-btn.remove:hover { border-color:orange; box-shadow:0 0 15px orange; }
.neon-btn.pending { border-color:yellow; box-shadow:0 0 10px yellow; color:yellow; cursor:default; }

/* --- Input fields (Updated to include file input styling) --- */
input[type="text"], input[type="number"], textarea, select, input[type="file"] { flex-grow:1; padding:10px; border:1px solid cyan; background:#181818; color:white; border-radius:6px; font-family:inherit; outline:none; transition:border-color 0.2s, box-shadow 0.2s; }
input:focus, textarea:focus, select:focus { border-color: magenta; box-shadow: 0 0 8px magenta; }
textarea { resize: vertical; }

/* --- Cards (Updated for badge positioning) --- */
.card-container { display:flex; flex-wrap:wrap; gap:20px; justify-content:center; padding-top: 10px; }
.card { 
    position:relative; /* Crucial for badge positioning */ 
    width: 100%; max-width:300px; padding:20px; border:3px solid transparent; border-radius:8px; background:#181818; box-shadow:0 0 15px rgba(0,255,255,0.4), inset 0 0 5px rgba(0,255,255,0.2); 
    border-image-source: linear-gradient(45deg, cyan, magenta, cyan); border-image-slice:1; 
    display:flex; flex-direction:column; align-items:center; cursor:pointer; transition: transform 0.2s, box-shadow 0.2s; 
}
.card:hover { transform: translateY(-5px); box-shadow:0 0 30px magenta, inset 0 0 10px rgba(255,0,255,0.5); }
.request-card { cursor:default; border:3px solid orange; box-shadow:0 0 15px orange; }
.request-card:hover { transform:none; box-shadow:0 0 15px orange; }

.card-content-box { display:flex; flex-direction:column; align-items:center; width:100%; margin-bottom:15px; padding-bottom:15px; border-bottom:1px dashed #333; }
/* Avatar styling for profile picture */
.avatar { width:80px; height:80px; border-radius:50%; border:4px solid magenta; object-fit:cover; margin-bottom:15px; }
.skill-rating { color:gold; font-size:1.4em; margin-bottom:10px; }

/* --- Badge Styling --- */
.badge {
    position: absolute;
    top: 5px;
    right: 5px;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.75em;
    font-weight: 700;
    text-transform: uppercase;
    font-family: 'Orbitron', sans-serif;
    letter-spacing: 1px;
    z-index: 10; /* Ensure badge is on top */
}

/* Specific styling for the target user's badge (Pilex6 / kHsYFJVHCGfQzI16nJH0mg1rv7u1) */
.badge.pilex6 {
    background: rgba(0, 255, 0, 0.1); /* Subtle background */
    color: #ccff00; /* Neon Green */
    border: 2px solid #ccff00;
    box-shadow: 0 0 8px #ccff00, inset 0 0 4px #ccff00;
}
.badge.pilex6::before {
    content: "Pilex6";
}

/* Example of a standard DEV/CO-FOUNDER badge for comparison (if applicable) */
.badge.dev {
    background: rgba(0, 255, 255, 0.1); 
    color: cyan;
    border: 2px solid cyan;
    box-shadow: 0 0 8px cyan, inset 0 0 4px cyan;
}

</style>
</head>
<body>

<div class="header">
    <div class="header-top">
        <div class="icon-container">‚ö°</div>
        <h1>DUO UP</h1>
    </div>
    <p id="welcomeMessage" class="welcome-text hidden">Welcome, User Loading...</p>
</div>

<div class="container">
    
    <div id="profileEditSection" class="hidden" style="background:#151515; padding:20px; border-radius:8px; border:1px solid #333;">
        <h2>‚öôÔ∏è Edit Profile</h2>
        <div style="margin-bottom: 15px;">
            <label for="profilePictureUpload" style="display:block; margin-bottom: 5px;">Change Profile Picture</label>
            <input type="file" id="profilePictureUpload" accept="image/*"> 
        </div>
        
        <input type="text" id="editUsername" placeholder="Username" style="margin-bottom: 10px;">
        <textarea id="editBio" placeholder="Tell us about yourself..." style="margin-bottom: 15px;"></textarea>
        
        <button class="neon-btn add" id="saveProfileBtn">Save Changes</button>
    </div>

    <div id="app-content">
        <h2>üî• Find Your Duo</h2>
        
        <div class="card-container" id="playerList">
            
            <div class="card" data-user-id="kHsYFJVHCGfQzI16nJH0mg1rv7u1">
                <span class="badge pilex6"></span> 
                <div class="card-content-box">
                    <img class="avatar" src="https://example.com/default-avatar.png" alt="Profile Picture">
                    <h3>Pilex6</h3>
                    <p class="skill-rating">‚≠ê 5.0</p>
                </div>
                <button class="neon-btn">Request Duo</button>
            </div>

            <div class="card" data-user-id="someOtherUserId123">
                <span class="badge hidden"></span> 
                <div class="card-content-box">
                    <img class="avatar" src="https://example.com/other-user-avatar.jpg" alt="Profile Picture">
                    <h3>ExamplePlayer</h3>
                    <p class="skill-rating">‚≠ê 4.2</p>
                </div>
                <button class="neon-btn">Request Duo</button>
            </div>
            
        </div>
    </div>
    
</div>

<script src="path/to/your/app.js"></script>

</body>
</html>     };
            }
        });

        container.innerHTML=""; 

        allUsersCache.forEach(user=>{
            if(user.id===currentUser.uid) return;
            const card=renderUserCard(user.id, user, requestCache[user.id]);
            if(card) container.appendChild(card);
        });

    }catch(e){ 
        container.innerHTML=`<p style="width:100%; text-align:center; color:red;">
            ACCESS DENIED [UID: ${currentUser?.uid || 'NONE'}] - 
            Error loading users: ${e.message}</p>
            <p style="width:100%; text-align:center; color:yellow;">
            **CRITICAL:** Ensure Firebase Security Rules are deployed correctly.
            </p>`; 
    }
}

// ---------------------------
// User Rendering Functions
// ---------------------------
function renderUserCard(uid, data, requestInfo){
    if(!data) return null;
    const card=document.createElement('div');
    card.className='card';
    card.onclick=()=>viewProfile(uid, data);
    const statusClass=(data.status||'Online').replace(/\s/g,'').toLowerCase();
    const badge = getCoFounderBadge(uid);
    
    const gameCategory = data.gameCategory || 'Other';
    const gameCategoryClass = `game-category-${gameCategory.toLowerCase().replace(/\s/g, '')}`;
    const gameRole = data.gameRole || 'Generalist';
    const lfdCategory = data.lfdCategory || null; 

    let cardButtons;
    
    if (requestInfo) {
        if (requestInfo.status === 'pending') {
            if (requestInfo.senderId === currentUser.uid) {
                cardButtons = `<button class="neon-btn pending" disabled>Pending (Waiting for reply)</button>`; 
            } else {
                cardButtons = `<button class="neon-btn add" onclick="event.stopPropagation(); acceptFriendRequest('${requestInfo.id}')">Accept Request</button>
                               <button class="neon-btn remove" onclick="event.stopPropagation(); rejectFriendRequest('${requestInfo.id}')">Reject</button>`;
            }
        } else if (requestInfo.status === 'accepted') {
            cardButtons = `<button class="neon-btn" style="border-color:lime; color:lime;" onclick="event.stopPropagation(); showTab('messaging'); selectChat('${requestInfo.id}', '${uid}')">Duo Active</button>`;
        } else {
            // Rejected or other state, allow new request
            cardButtons = `<button class="neon-btn add" onclick="event.stopPropagation(); sendFriendRequest('${uid}')">Send Request</button>`;
        }
    } else {
        cardButtons = `<button class="neon-btn add" onclick="event.stopPropagation(); sendFriendRequest('${uid}')">Send Request</button>`;
    }
    
    let lfdCategoryDisplay = '';
    if (data.status === 'LFD' && lfdCategory) {
        lfdCategoryDisplay = `<div class="lfd-category">${lfdCategory}</div>`;
    }

    card.innerHTML=`
        <div class="card-content-box">
        <img src="${data.profileImageUrl||DEFAULT_AVATAR}" class="avatar">
        <div class="nickname-group">
            <h3 style="margin:0;">${data.nickname||'Unknown'}</h3>
            ${badge}
        </div>
        <div class="game-category ${gameCategoryClass}">${gameCategory.replace(/([A-Z])/g, ' $1').trim()}</div>
        <div class="game-role">${gameRole.replace(/([A-Z])/g, ' $1').trim()}</div>
        ${lfdCategoryDisplay} 
        <div class="skill-rating">${'‚≠ê'.repeat(data.skillRating||3)}</div>
        <div class="status-indicator status-${statusClass}">${data.status||'Online'}</div>
        <p style="margin:5px 0; font-size:0.9em; text-align:center; color:#ccc;">${data.bio||'No bio provided.'}</p>
        </div>
        ${cardButtons}
    `;
    return card;
}

function renderDuoCard(uid, data) {
    if(!data) return null;
    const card = document.createElement('div');
    card.className = 'card';
    card.onclick = () => viewProfile(uid, data); 

    const statusClass = (data.status || 'Online').replace(/\s/g,'').toLowerCase();
    const badge = getCoFounderBadge(uid);
    const chatId = getChatId(uid);

    card.innerHTML = `
        <div class="card-content-box" style="border-bottom: none;">
            <img src="${data.profileImageUrl||DEFAULT_AVATAR}" class="avatar">
            <div class="nickname-group">
                <h3 style="margin:0;">${data.nickname||'Unknown'}</h3>
                ${badge}
            </div>
            <p style="margin:5px 0; font-size:0.9em; color:lime;">YOUR DUO</p>
            <div class="status-indicator status-${statusClass}">${data.status||'Online'}</div>
        </div>
        <button class="neon-btn" style="border-color:magenta; box-shadow:0 0 10px magenta;" 
                onclick="event.stopPropagation(); showTab('messaging'); selectChat('${chatId}', '${uid}')">
            Message Duo
        </button>
    `;
    return card;
}


// ---------------------------
// Duos/Requests Logic 
// ---------------------------

async function loadFriends() {
    if (!currentUser) return;
    const pendingContainer = document.getElementById('pendingRequestsList');
    const acceptedContainer = document.getElementById('friendList');
    pendingContainer.innerHTML = '<h3>Scanning for Incoming Requests...</h3>';
    acceptedContainer.innerHTML = '<h3>Establishing Connection to Accepted Duos...</h3>';

    // Reload users/requests cache to ensure fresh data
    await loadAllUsers(); 

    const pendingRequests = [];
    const acceptedDuos = [];
    
    // Iterate through the request cache
    for (const otherUid in requestCache) {
        const req = requestCache[otherUid];
        const partner = findUserInCache(otherUid);

        if (!partner) continue; 

        if (req.status === 'pending' && req.receiverId === currentUser.uid) {
            // Incoming pending request
            pendingRequests.push(partner);
        } else if (req.status === 'accepted') {
            // Accepted duo
            acceptedDuos.push(partner);
        }
    }
    
    // Render Pending Requests
    pendingContainer.innerHTML = pendingRequests.length > 0 
        ? '' 
        : '<p style="width:100%; text-align:center;">No incoming requests.</p>';

    pendingRequests.forEach(user => {
        const card = renderUserCard(user.id, user, requestCache[user.id]);
        if (card) pendingContainer.appendChild(card);
    });

    // Render Accepted Duos
    acceptedContainer.innerHTML = acceptedDuos.length > 0 
        ? '' 
        : '<p style="width:100%; text-align:center; color:magenta;">You have no active Duos. Send a request from the Suggested tab!</p>';

    acceptedDuos.forEach(user => {
        const card = renderDuoCard(user.id, user);
        if (card) acceptedContainer.appendChild(card);
    });
}

// ---------------------------
// Friend Request Actions
// ---------------------------

async function sendFriendRequest(otherUid) {
    if (!currentUser) return alert("Please log in first.");

    const requestId = getChatId(otherUid); // UID1_UID2 format
    const senderId = currentUser.uid;
    
    if (requestCache[otherUid] && requestCache[otherUid].status !== 'rejected' && requestCache[otherUid].status !== 'deleted') {
        return alert(`A request status is already: ${requestCache[otherUid].status}.`);
    }

    try {
        await db.collection('friendRequests').doc(requestId).set({
            senderId: senderId,
            receiverId: otherUid,
            status: 'pending',
            // CRITICAL: The array field needed for security rules and queries
            participants: [senderId, otherUid].sort(), 
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        alert("Friend request sent successfully!");
        // Reload the current view to update button status
        showTab('allUsers'); 

    } catch (e) {
        console.error("Error sending request:", e);
        alert(`Error: Could not send request. Check console. Error: ${e.message}`);
    }
}

async function acceptFriendRequest(requestId) {
    if (!currentUser) return;
    try {
        await db.collection('friendRequests').doc(requestId).update({
            status: 'accepted',
            acceptedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        alert("Request Accepted! Duo connection established.");
        loadFriends();
    } catch (e) {
        console.error("Error accepting request:", e);
        alert("Error accepting request. Check Firestore Rules/Permissions.");
    }
}

async function rejectFriendRequest(requestId) {
    if (!currentUser) return;
    try {
        // We delete the document to keep the database clean
        await db.collection('friendRequests').doc(requestId).delete();
        alert("Request Rejected/Canceled.");
        loadFriends();
    } catch (e) {
        console.error("Error rejecting request:", e);
        alert("Error rejecting request. Check Firestore Rules/Permissions.");
    }
}

// ---------------------------
// Messaging Functions
// ---------------------------

async function loadChatList() {
    if (!currentUser) return;
    const container = document.getElementById('activeDuoList');
    container.innerHTML = 'Retrieving active duos...';
    
    try {
        // Query accepted requests where current user is a participant
        // This query relies on the 'participants' array and 'status' fields.
        const duoSnap = await db.collection('friendRequests')
            .where('participants', 'array-contains', currentUser.uid)
            .where('status', '==', 'accepted')
            .get();

        container.innerHTML = '';
        if (duoSnap.empty) {
            container.innerHTML = '<p>No active duos. Accept a request or send one!</p>';
            return;
        }

        // --- Active Chat Entry Rendering ---
        duoSnap.docs.forEach(doc => {
            const duoData = doc.data();
            const chatId = doc.id;
            const otherUid = duoData.participants.find(uid => uid !== currentUser.uid);
            const partner = findUserInCache(otherUid);
            if (!partner) return;

            const chatEntry = document.createElement('div');
            chatEntry.className = 'chat-entry';
            chatEntry.textContent = partner.nickname || partner.id;
            // Pass the canonical chatId and the partner's UID
            chatEntry.onclick = () => selectChat(chatId, otherUid);
            container.appendChild(chatEntry);
        });

    } catch (e) {
        console.error("Error loading chat list:", e);
        container.innerHTML = `<p style="color:red;">Error loading chats: ${e.message}. Check Firestore Rules/Index.</p>`;
    }
}

async function selectChat(chatId, otherUid) {
    if (chatListener) chatListener(); // Stop previous listener

    currentChatId = chatId;
    currentChatPartnerId = otherUid;
    const partner = findUserInCache(otherUid);
    const partnerNickname = partner?.nickname || 'Unknown Duo';

    document.getElementById('chatHeader').textContent = `Chatting with: ${partnerNickname}`;
    document.getElementById('messageDisplay').innerHTML = '';
    document.getElementById('messageInputArea').classList.remove('hidden');

    // Add 'active' class to the selected chat entry
    document.querySelectorAll('.chat-entry').forEach(e => e.classList.remove('active'));
    // Simple way to find the corresponding entry (may need refinement if names aren't unique)
    document.querySelector(`#activeDuoList div:contains(${partnerNickname})`)?.classList.add('active');


    const messageRef = db.collection('chats').doc(chatId).collection('messages');
    
    // Start the real-time listener for messages
    chatListener = messageRef.orderBy('timestamp', 'asc').limit(50).onSnapshot(snapshot => {
        const display = document.getElementById('messageDisplay');
        display.innerHTML = ''; // Clear display

        snapshot.forEach(doc => {
            const msg = doc.data();
            const messageElement = document.createElement('div');
            // Check if timestamp exists and convert it for display
            const timeString = msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString() : 'now';

            messageElement.className = `message ${msg.senderId === currentUser.uid ? 'sent' : 'received'}`;
            messageElement.innerHTML = `${msg.text}<span>${timeString}</span>`;
            display.appendChild(messageElement);
        });
        display.scrollTop = display.scrollHeight; // Scroll to bottom
    }, error => {
        console.error("Message listener failed (Check Firestore rules for /chats/{chatId}/messages read permission):", error);
        document.getElementById('messageDisplay').innerHTML = `<p style="color:red;">Failed to load messages. Duo status required.</p>`;
    });
}

// *** FINAL CORRECTED SEND MESSAGE FUNCTION ***
async function sendMessage() {
    const inputElement = document.getElementById('messageInput');
    const text = inputElement.value.trim();

    if (!text || !currentChatId) return; // Must have content and a selected chat

    try {
        const chatDocRef = db.collection('chats').doc(currentChatId);
        
        // 1. Ensure the parent chat document exists (Lazy creation)
        const chatDoc = await chatDocRef.get();
        if (!chatDoc.exists) {
            // This set operation is protected by the 'allow create' rule for /chats/{chatId}
            await chatDocRef.set({
                participants: [currentUser.uid, currentChatPartnerId].sort(),
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });
        }

        // 2. Send the message
        // This add operation is protected by the 'allow create' rule for /messages
        await chatDocRef.collection('messages').add({
            text: text,
            senderId: currentUser.uid,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            // CRITICAL: Include chatId in the message document to satisfy security rules
            chatId: currentChatId 
        });
        
        inputElement.value = ''; // Clear input

    } catch (e) {
        console.error("Error sending message (Check Firestore rules or Duo Status):", e);
        alert("Failed to send message. Duo status must be 'accepted' and chat rules correct.");
    }
}


// ---------------------------
// Profile/Search Logic
// ---------------------------

function toggleLfdCategory() {
    const status = document.getElementById('profileStatus').value;
    const group = document.getElementById('lfdCategoryGroup');
    if (status === 'LFD') {
        group.classList.remove('hidden');
    } else {
        group.classList.add('hidden');
    }
}

async function loadUserProfile() {
    if (!currentUser) return;
    // Reload data for the current user to get the latest profile
    const doc = await db.collection('users').doc(currentUser.uid).get();
    const profile = doc.data() || {};
    currentProfileData = profile;

    document.getElementById('profileAvatar').src = profile.profileImageUrl || DEFAULT_AVATAR;
    document.getElementById('profileNickname').value = profile.nickname || '';
    document.getElementById('profileBio').value = profile.bio || '';
    document.getElementById('profileSkillRating').value = profile.skillRating || 3;
    document.getElementById('profileGameCategory').value = profile.gameCategory || 'Other';
    document.getElementById('profileGameRole').value = profile.gameRole || 'Generalist';
    document.getElementById('profileStatus').value = profile.status || 'Online';
    document.getElementById('profileLfdCategory').value = profile.lfdCategory || 'Duo';
    
    // Disable nickname editing if already used
    const nicknameInput = document.getElementById('profileNickname');
    const changeInfo = document.getElementById('nicknameChangeInfo');
    if (profile.nicknameChangeUsed === true) {
        nicknameInput.disabled = true;
        changeInfo.textContent = "(Nickname change already used.)";
        changeInfo.style.color = 'red';
    } else {
        nicknameInput.disabled = false;
        changeInfo.textContent = "(You get one free nickname change.)";
        changeInfo.style.color = 'yellow';
    }

}

function previewAvatar(event) {
    const file = event.target.files[0];
    if (file) {
        document.getElementById('profileAvatar').src = URL.createObjectURL(file);
    }
}

async function saveProfile() {
    if (!currentUser) return;
    const saveMessage = document.getElementById('saveMessage');
    saveMessage.textContent = 'Saving...';
    
    const nickname = document.getElementById('profileNickname').value;
    const nicknameChangeUsed = currentProfileData.nicknameChangeUsed || false;
    
    const updates = {
        nickname: nickname,
        bio: document.getElementById('profileBio').value,
        skillRating: parseInt(document.getElementById('profileSkillRating').value),
        gameCategory: document.getElementById('profileGameCategory').value,
        gameRole: document.getElementById('profileGameRole').value,
        status: document.getElementById('profileStatus').value,
        lfdCategory: document.getElementById('profileLfdCategory').value,
        lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
    };
    
    // Handle nickname change logic
    if (!nicknameChangeUsed && currentProfileData.nickname !== nickname) {
        updates.nicknameChangeUsed = true;
    } else if (nicknameChangeUsed && currentProfileData.nickname !== nickname) {
        saveMessage.textContent = 'Error: Nickname change is locked.';
        saveMessage.style.color = 'red';
        return;
    }

    try {
        // 1. Handle Avatar Upload (If new file is selected)
        const avatarFile = document.getElementById('avatarFile').files[0];
        if (avatarFile) {
            const storageRef = storage.ref(`avatars/${currentUser.uid}/${avatarFile.name}`);
            await storageRef.put(avatarFile);
            updates.profileImageUrl = await storageRef.getDownloadURL();
        }

        // 2. Update Firestore
        await db.collection('users').doc(currentUser.uid).update(updates);
        saveMessage.textContent = 'Profile Updated Successfully!';
        saveMessage.style.color = 'lime';
        
        // Refresh profile view
        loadUserProfile();

    } catch (e) {
        console.error("Error saving profile:", e);
        saveMessage.textContent = `Error saving: ${e.message}`;
        saveMessage.style.color = 'red';
    }
}


async function viewProfile(uid, data) {
    // Basic implementation to switch to the viewProfileTab
    document.getElementById('viewProfileTab').classList.remove('hidden');
    document.getElementById('allUsersTab').classList.add('hidden'); // Hide where we came from

    const content = document.getElementById('viewProfileContent');
    const badge = getCoFounderBadge(uid);
    const statusClass = (data.status||'Online').replace(/\s/g,'').toLowerCase();
    const gameCategoryClass = `game-category-${(data.gameCategory||'Other').toLowerCase().replace(/\s/g, '')}`;
    
    content.innerHTML = `
        <img src="${data.profileImageUrl||DEFAULT_AVATAR}" class="avatar" style="width:150px; height:150px; margin-bottom: 20px;">
        <div class="nickname-group">
            <h2 style="margin:0;">${data.nickname||'Unknown'}</h2>
            ${badge}
        </div>
        <div class="status-indicator status-${statusClass}">${data.status||'Online'}</div>
        <p style="color:#ccc; max-width: 400px; text-align: center; margin-bottom: 30px;">"${data.bio||'No bio provided.'}"</p>
        
        <div class="profile-stat">
            <span>Skill Rating</span>
            <span>${'‚≠ê'.repeat(data.skillRating||3)}</span>
        </div>
        <div class="profile-stat">
            <span>Primary Category</span>
            <span class="game-category ${gameCategoryClass}" style="margin:0;">${(data.gameCategory||'Other').replace(/([A-Z])/g, ' $1').trim()}</span>
        </div>
        <div class="profile-stat">
            <span>Preferred Role/Mode</span>
            <span class="game-role" style="margin:0;">${(data.gameRole||'Generalist').replace(/([A-Z])/g, ' $1').trim()}</span>
        </div>
        ${data.status === 'LFD' && data.lfdCategory ? 
        `<div class="profile-stat">
            <span>LFD Goal</span>
            <span class="lfd-category" style="margin:0;">${data.lfdCategory}</span>
        </div>` : ''}

        <button class="neon-btn add" style="margin-top: 20px;" onclick="sendFriendRequest('${uid}')">SEND DUO UP REQUEST</button>
    `;

}

function filterSearchResults() {
    // This is a client-side filter since all users are loaded into allUsersCache
    const query = document.getElementById('searchInput').value.toLowerCase();
    const status = document.getElementById('statusFilter').value;
    const category = document.getElementById('gameCategoryFilter').value;
    const role = document.getElementById('gameRoleFilter').value;
    const lfd = document.getElementById('lfdCategoryFilter').value;

    const resultsContainer = document.getElementById('searchResults');
    resultsContainer.innerHTML = '';

    const filteredUsers = allUsersCache.filter(user => {
        if (user.id === currentUser.uid) return false;
        
        const matchesQuery = !query || 
                             (user.nickname && user.nickname.toLowerCase().includes(query)) ||
                             (user.bio && user.bio.toLowerCase().includes(query));

        const matchesStatus = !status || user.status === status;
        const matchesCategory = !category || user.gameCategory === category;
        const matchesRole = !role || user.gameRole === role;
        const matchesLfd = !lfd || user.lfdCategory === lfd;
        
        return matchesQuery && matchesStatus && matchesCategory && matchesRole && matchesLfd;
    });

    if (filteredUsers.length === 0) {
        resultsContainer.innerHTML = '<p style="width:100%; text-align:center;">No matching players found.</p>';
        return;
    }

    filteredUsers.forEach(user => {
        const card = renderUserCard(user.id, user, requestCache[user.id]);
        if (card) resultsContainer.appendChild(card);
    });
}


// FIX for jQuery style selector not being available
if (typeof NodeList.prototype.forEach !== 'function') {
    NodeList.prototype.forEach = Array.prototype.forEach;
}
if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
if (!Element.prototype.closest) {
    Element.prototype.closest = function(s) {
        let el = this;
        do {
            if (el.matches(s)) return el;
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
    };
}
// Simple contains polyfill/extension for querySelector
if (window.Element && !Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
document.querySelector = (function(orig) {
    return function(selector) {
        if (selector.includes(':contains')) {
            const [base, text] = selector.split(':contains');
            const target = text.match(/\((.*?)\)/)[1].replace(/['"]/g, '');
            // We use Array.from and find for a safer check instead of NodeList iteration
            return Array.from(document.querySelectorAll(base)).find(e => e.textContent.includes(target));
        }
        return orig.call(this, selector);
    };
})(document.querySelector);


// ----------------------------------------------------
// 4. START APPLICATION
// ----------------------------------------------------
initFirebase();
</script>

</body>
</html>







