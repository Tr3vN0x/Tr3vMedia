// ... (Continued from the index.php file you provided) ...

            <option value="Mentor">Mentor/Mentee</option>
        </select>
    </div>
</div>
<button class="neon-btn" style="border-color:#00ff00; box-shadow:0 0 10px #00ff00;" onclick="saveProfile()">Save Profile</button>
<p id="saveMessage" style="color:#00ff00; margin-top:10px;"></p>
</div>
</div>

<script>
// ----------------------------------------------------
// 0. GLOBAL VARS AND UTILITIES (Repeated for completeness, but should match your file)
// ----------------------------------------------------
let auth;
let db;
// ... (Your global vars) ...
let currentUser = null;
let currentProfileData = {};
let allUsersCache = [];
let requestCache = {};
let currentChatId = null;
let chatListener = null;
let currentChatPartnerId = null; 

const DEFAULT_AVATAR = "https://cdn-icons-png.flaticon.com/512/149/149071.png";

// ... (Your firebaseConfig and get*Badge functions) ...

// Utility Functions (Matching previous structure)
function getChatId(otherUid) {
    return [currentUser.uid, otherUid].sort().join('_');
}
function getCanonicalId(uid1, uid2) {
    return uid1 < uid2 ? uid1 + "_" + uid2 : uid2 + "_" + uid1;
}
function findUserInCache(uid) {
    return allUsersCache.find(user => user.id === uid);
}

// ... (Your initFirebase, checkAndCreateUserProfile, login, logout, showTab, loadAllUsers, renderUserCard, renderDuoCard functions) ...

// ----------------------------------------------------
// 2. PROFILE EDITOR FUNCTIONS (Continued and Completed)
// ----------------------------------------------------

// NEW FUNCTION: Updates the profile avatar preview from the URL field
function previewUrl(url) {
    document.getElementById('profileAvatar').src = url.trim() || DEFAULT_AVATAR;
}

// NEW FUNCTION: Toggle LFD Category Visibility
function toggleLfdCategory() {
    const status = document.getElementById('profileStatus').value;
    const lfdGroup = document.getElementById('lfdCategoryGroup');
    if (status === 'LFD') {
        lfdGroup.classList.remove('hidden');
    } else {
        lfdGroup.classList.add('hidden');
    }
}

async function loadUserProfile() {
    if (!currentUser) return;
    const userDocRef = db.collection('users').doc(currentUser.uid);
    const doc = await userDocRef.get();
    
    if (doc.exists) {
        currentProfileData = doc.data();
        
        document.getElementById('profileNickname').value = currentProfileData.nickname || '';
        document.getElementById('profileBio').value = currentProfileData.bio || '';
        document.getElementById('profileSkillRating').value = currentProfileData.skillRating || 3;
        document.getElementById('profileGameCategory').value = currentProfileData.gameCategory || 'Other';
        document.getElementById('profileGameRole').value = currentProfileData.gameRole || 'Generalist';
        document.getElementById('profileStatus').value = currentProfileData.status || 'Online';
        document.getElementById('profileLfdCategory').value = currentProfileData.lfdCategory || 'Duo';
        document.getElementById('profileImageUrlInput').value = currentProfileData.profileImageUrl || '';
        document.getElementById('profileAvatar').src = currentProfileData.profileImageUrl || DEFAULT_AVATAR;

        const nicknameChangeInfo = document.getElementById('nicknameChangeInfo');
        if (currentProfileData.nicknameChangeUsed) {
            document.getElementById('profileNickname').disabled = true;
            nicknameChangeInfo.textContent = '(Nickname change already used.)';
            nicknameChangeInfo.style.color = 'red';
        } else {
            document.getElementById('profileNickname').disabled = false;
            nicknameChangeInfo.textContent = '(You get one free nickname change.)';
            nicknameChangeInfo.style.color = 'yellow';
        }

        toggleLfdCategory();
    }
}

// SAVE PROFILE FUNCTION (Completed)
async function saveProfile() {
    if (!currentUser) return;
    const saveMessage = document.getElementById('saveMessage');
    saveMessage.textContent = 'Saving...';
    saveMessage.style.color = 'yellow';

    const newNickname = document.getElementById('profileNickname').value.trim();
    const oldNickname = currentProfileData.nickname;
    const isNicknameChanged = newNickname !== oldNickname;
    const isChangeUsed = currentProfileData.nicknameChangeUsed;

    if (isNicknameChanged && isChangeUsed) {
        saveMessage.textContent = 'Error: You have already used your one free nickname change.';
        saveMessage.style.color = 'red';
        return;
    }

    if (isNicknameChanged && newNickname.length < 3) {
        saveMessage.textContent = 'Error: Nickname must be at least 3 characters long.';
        saveMessage.style.color = 'red';
        return;
    }

    try {
        const profileData = {
            nickname: newNickname,
            bio: document.getElementById('profileBio').value.trim(),
            skillRating: parseInt(document.getElementById('profileSkillRating').value),
            gameCategory: document.getElementById('profileGameCategory').value,
            gameRole: document.getElementById('profileGameRole').value,
            status: document.getElementById('profileStatus').value,
            profileImageUrl: document.getElementById('profileImageUrlInput').value || DEFAULT_AVATAR,
        };

        if (profileData.status === 'LFD') {
            profileData.lfdCategory = document.getElementById('profileLfdCategory').value;
        } else {
            profileData.lfdCategory = firebase.firestore.FieldValue.delete();
        }

        if (isNicknameChanged && !isChangeUsed) {
            profileData.nicknameChangeUsed = true;
        }

        await db.collection('users').doc(currentUser.uid).update(profileData);
        
        // Re-load profile to update the cache and UI
        const doc = await db.collection('users').doc(currentUser.uid).get();
        currentProfileData = doc.data();
        document.getElementById('welcome').textContent = `WELCOME ${currentProfileData.nickname.toUpperCase()} TO DUO UP!`;
        loadUserProfile();

        saveMessage.textContent = 'Profile successfully saved!';
        saveMessage.style.color = '#00ff00';
        setTimeout(() => { saveMessage.textContent = ''; }, 3000);

    } catch (e) {
        console.error("Error saving profile: ", e);
        saveMessage.textContent = 'Error saving profile: ' + e.message;
        saveMessage.style.color = 'red';
    }
}


// ----------------------------------------------------
// 3. SEARCH & FILTERING
// ----------------------------------------------------

function filterSearchResults() {
    const searchInput = document.getElementById('searchInput').value.toLowerCase();
    const statusFilter = document.getElementById('statusFilter').value;
    const gameCategoryFilter = document.getElementById('gameCategoryFilter').value;
    const gameRoleFilter = document.getElementById('gameRoleFilter').value;
    const lfdCategoryFilter = document.getElementById('lfdCategoryFilter').value;
    const resultsContainer = document.getElementById('searchResults');
    resultsContainer.innerHTML = ''; 

    const filteredUsers = allUsersCache.filter(user => {
        if (user.id === currentUser.uid) return false;

        // Search Text
        const textMatch = searchInput === '' ||
            (user.nickname && user.nickname.toLowerCase().includes(searchInput)) ||
            (user.bio && user.bio.toLowerCase().includes(searchInput));
        if (!textMatch) return false;

        // Filters
        if (statusFilter && user.status !== statusFilter) return false;
        if (gameCategoryFilter && user.gameCategory !== gameCategoryFilter) return false;
        if (gameRoleFilter && user.gameRole !== gameRoleFilter) return false;
        
        // LFD Filter
        if (lfdCategoryFilter && user.status === 'LFD' && user.lfdCategory !== lfdCategoryFilter) return false;
        if (lfdCategoryFilter && user.status !== 'LFD' && lfdCategoryFilter !== '') return false;

        return true;
    });

    if (filteredUsers.length === 0) {
        resultsContainer.innerHTML = '<p style="width:100%; text-align:center;">No matching players found.</p>';
        return;
    }

    filteredUsers.forEach(user => {
        // Use the existing renderUserCard, but we need the requestInfo from the cache
        const card = renderUserCard(user.id, user, requestCache[user.id]);
        if (card) resultsContainer.appendChild(card);
    });
}


// ----------------------------------------------------
// 4. DUOS (FRIENDS) MANAGEMENT
// ----------------------------------------------------

async function loadFriends() {
    // 1. Ensure user data is loaded (it is done in loadAllUsers, but good to ensure cache is fresh)
    await loadAllUsers(); 

    const pendingRequests = [];
    const acceptedDuos = [];
    
    // We already populate requestCache in loadAllUsers
    for (const partnerId in requestCache) {
        const request = requestCache[partnerId];
        const user = findUserInCache(partnerId);

        if (!user) continue;

        if (request.status === 'pending') {
            // Check if WE are the receiver
            if (request.receiverId === currentUser.uid) {
                pendingRequests.push(user);
            }
        } else if (request.status === 'accepted') {
            acceptedDuos.push(user);
        }
    }

    // Render Pending Requests
    const pendingContainer = document.getElementById('pendingRequestsList');
    pendingContainer.innerHTML = '';
    if (pendingRequests.length === 0) {
        pendingContainer.innerHTML = '<p style="width:100%; text-align:center; color:magenta;">No incoming requests.</p>';
    } else {
        pendingRequests.forEach(user => {
            // Re-render the card, which will show the Accept/Reject buttons based on requestCache
            const card = renderUserCard(user.id, user, requestCache[user.id]);
            if (card) {
                card.classList.add('request-card'); // Highlight the card
                pendingContainer.appendChild(card);
            }
        });
    }

    // Render Accepted Duos
    const friendContainer = document.getElementById('friendList');
    friendContainer.innerHTML = '';
    if (acceptedDuos.length === 0) {
        friendContainer.innerHTML = '<p style="width:100%; text-align:center; color:magenta;">You have no active Duos.</p>';
    } else {
        acceptedDuos.forEach(user => {
            const card = renderDuoCard(user.id, user); // Use the cleaner Duo card render
            if (card) friendContainer.appendChild(card);
        });
    }
}

async function sendFriendRequest(receiverUid) {
    if (!currentUser) return;

    try {
        const requestId = getCanonicalId(currentUser.uid, receiverUid);

        await db.collection('friendRequests').doc(requestId).set({
            senderId: currentUser.uid,
            receiverId: receiverUid,
            participants: [currentUser.uid, receiverUid],
            status: 'pending',
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        alert(`Duo request sent to ${findUserInCache(receiverUid)?.nickname || receiverUid}!`);
        // Refresh the current tab to update buttons/status
        showTab(document.querySelector('#navigationBar button.active').id.replace('tab-', '')); 

    } catch (e) {
        console.error("Error sending request: ", e);
        alert("Failed to send request. Check console.");
    }
}

async function acceptFriendRequest(requestId) {
    if (!currentUser) return;

    try {
        await db.collection('friendRequests').doc(requestId).update({
            status: 'accepted',
            acceptedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        // The request ID contains the two UIDs, we need to extract the partner's UID
        const [uid1, uid2] = requestId.split('_');
        const partnerUid = uid1 === currentUser.uid ? uid2 : uid1;

        alert(`You are now Duos with ${findUserInCache(partnerUid)?.nickname || partnerUid}!`);
        loadFriends(); 

    } catch (e) {
        console.error("Error accepting request: ", e);
        alert("Failed to accept request. Check console.");
    }
}

async function rejectFriendRequest(requestId) {
    if (!currentUser) return;

    try {
        await db.collection('friendRequests').doc(requestId).delete();

        alert(`Duo request rejected.`);
        loadFriends(); 

    } catch (e) {
        console.error("Error rejecting request: ", e);
        alert("Failed to reject request. Check console.");
    }
}

async function removeDuo(partnerUid) {
    if (!currentUser) return;

    if (!confirm(`Are you sure you want to remove ${findUserInCache(partnerUid)?.nickname || partnerUid} as a Duo? This will also clear your chat history with them.`)) {
        return;
    }

    try {
        const requestId = getCanonicalId(currentUser.uid, partnerUid);
        const chatId = getCanonicalId(currentUser.uid, partnerUid);

        // 1. Delete the friend request document
        await db.collection('friendRequests').doc(requestId).delete();

        // 2. Delete all chat messages (This can be slow/expensive for large chats)
        const messagesSnapshot = await db.collection('chats').doc(chatId).collection('messages').get();
        const batch = db.batch();
        messagesSnapshot.docs.forEach(doc => {
            batch.delete(doc.ref);
        });
        await batch.commit();

        alert(`Duo relationship with ${findUserInCache(partnerUid)?.nickname || partnerUid} removed.`);
        loadFriends(); 
        
    } catch (e) {
        console.error("Error removing duo: ", e);
        alert("Failed to remove Duo. Check console.");
    }
}


// ----------------------------------------------------
// 5. VIEW PROFILE
// ----------------------------------------------------

function viewProfile(uid) {
    const user = findUserInCache(uid);
    if (!user) {
        alert("User profile data not found in cache. Try refreshing the tab.");
        return;
    }
    
    // Check request cache to determine button state
    const requestInfo = requestCache[uid];
    
    renderFullProfile(user, requestInfo);
    
    // Hide all tabs and show viewProfileTab
    document.querySelectorAll('#allUsersTab,#searchTab,#friendsTab,#messagingTab,#profileTab,#viewProfileTab').forEach(e=>e.classList.add('hidden'));
    document.getElementById('viewProfileTab').classList.remove('hidden');
}

function renderFullProfile(user, requestInfo) {
    const container = document.getElementById('viewProfileContent');
    if (!container) return;

    let buttonHTML = '';
    const isDuos = requestInfo && requestInfo.status === 'accepted';
    const isPending = requestInfo && requestInfo.status === 'pending';
    const isSentByMe = isPending && requestInfo.senderId === currentUser.uid;
    const isSentToMe = isPending && requestInfo.receiverId === currentUser.uid;

    if (isDuos) {
        buttonHTML = `
            <button class="neon-btn remove" onclick="event.stopPropagation(); removeDuo('${user.id}')">Remove Duo</button>
            <button class="neon-btn" style="border-color:lime; box-shadow:0 0 10px lime;" onclick="event.stopPropagation(); showTab('messaging'); selectChat('${getChatId(user.id)}', '${user.id}')">Message Duo</button>
        `;
    } else if (isSentByMe) {
        buttonHTML = `<button class="neon-btn pending" disabled>Request Sent</button>`;
    } else if (isSentToMe) {
        buttonHTML = `
            <button class="neon-btn add" onclick="event.stopPropagation(); acceptFriendRequest('${requestInfo.id}')">Accept Duo</button>
            <button class="neon-btn remove" onclick="event.stopPropagation(); rejectFriendRequest('${requestInfo.id}')">Reject</button>
        `;
    } else {
        buttonHTML = `<button class="neon-btn add" onclick="event.stopPropagation(); sendFriendRequest('${user.id}')">Send Duo Request</button>`;
    }

    const statusClass = `status-${user.status.toLowerCase().replace(/\s/g, '')}`;
    const categoryClass = `game-category-${(user.gameCategory || 'other').toLowerCase()}`;
    const lfdGoal = user.status === 'LFD' && user.lfdCategory ? `<div class="lfd-category">${user.lfdCategory} LFD</div>` : '';


    container.innerHTML = `
        <img class="avatar" src="${user.profileImageUrl || DEFAULT_AVATAR}" style="width:120px; height:120px; border-color:cyan;" onerror="this.src='${DEFAULT_AVATAR}'">
        <div class="nickname-group" style="margin-top:15px;">
            <h2 style="color:cyan;">${user.nickname}</h2>
            ${getCoFounderBadge(user.id)}
            ${getCustomBadge(user.id)}
        </div>
        <div class="status-indicator ${statusClass}">${user.status}</div>
        ${lfdGoal}
        
        <p style="text-align:center; font-style:italic; max-width:500px; margin-top:20px;">"${user.bio || 'No bio provided.'}"</p>

        <div style="width:100%; max-width:400px; margin-top:20px;">
            <div class="profile-stat"><span>Skill Rating:</span><span>${'⭐'.repeat(user.skillRating)} (${user.skillRating || 3}/5)</span></div>
            <div class="profile-stat"><span>Primary Category:</span><span class="${categoryClass} game-category" style="box-shadow:none;">${(user.gameCategory || 'Other').replace(/([A-Z])/g, ' $1').trim()}</span></div>
            <div class="profile-stat"><span>Game Role:</span><span class="game-role" style="box-shadow:none;">${(user.gameRole || 'Generalist').replace(/([A-Z])/g, ' $1').trim()}</span></div>
            <div class="profile-stat"><span>Joined:</span><span>${user.createdAt ? new Date(user.createdAt.seconds * 1000).toLocaleDateString() : 'N/A'}</span></div>
        </div>

        <div style="display:flex; justify-content:center; gap:10px; margin-top:30px;">
            ${buttonHTML}
        </div>
    `;
}


// ----------------------------------------------------
// 6. MESSAGING
// ----------------------------------------------------

async function loadChatList() {
    if (!currentUser) return;
    
    // Ensure duos and user data are cached
    await loadAllUsers();

    const activeDuos = [];
    for (const partnerId in requestCache) {
        const request = requestCache[partnerId];
        if (request.status === 'accepted') {
            const user = findUserInCache(partnerId);
            if (user) activeDuos.push(user);
        }
    }

    const listContainer = document.getElementById('activeDuoList');
    listContainer.innerHTML = activeDuos.length > 0
        ? activeDuos.map(user => `
            <div class="chat-entry" data-uid="${user.id}" onclick="selectChat('${getChatId(user.id)}', '${user.id}')">
                ${user.nickname}
            </div>
          `).join('')
        : '<p style="color:gray; text-align:center;">You have no active Duos to message.</p>';
}

function selectChat(chatId, partnerUid) {
    if (!currentUser || !partnerUid) return;

    // 1. Clean up previous listener
    if (chatListener) {
        chatListener(); 
        chatListener = null;
    }

    // 2. Set current chat context
    currentChatPartnerId = partnerUid;
    currentChatId = chatId;
    const partner = findUserInCache(partnerUid);

    // 3. Update UI
    document.getElementById('chatHeader').textContent = `Chatting with: ${partner?.nickname || 'Duo'}`;
    document.getElementById('messageDisplay').innerHTML = ''; // Clear display for new chat
    document.getElementById('messageInputArea').classList.remove('hidden');
    document.querySelectorAll('.chat-entry').forEach(e => e.classList.remove('active'));
    document.querySelector(`.chat-entry[data-uid="${partnerUid}"]`)?.classList.add('active');


    // 4. Set up new chat listener
    const messagesRef = db.collection('chats').doc(currentChatId).collection('messages').orderBy('timestamp');

    chatListener = messagesRef.onSnapshot(snapshot => {
        const messageDisplay = document.getElementById('messageDisplay');
        let shouldScroll = messageDisplay.scrollTop + messageDisplay.clientHeight >= messageDisplay.scrollHeight - 50; // Check if user is near bottom

        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const message = change.doc.data();
                const isSent = message.senderUid === currentUser.uid;
                const time = message.timestamp ? new Date(message.timestamp.seconds * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
                
                // Append message directly (safer than using innerHTML for full rebuild)
                const msgDiv = document.createElement('div');
                msgDiv.className = `message ${isSent ? 'sent' : 'received'}`;
                msgDiv.innerHTML = `${message.content}<span>${time}</span>`;
                messageDisplay.appendChild(msgDiv);
            }
        });

        // Scroll to bottom if the user was already near the bottom
        if (shouldScroll) {
             messageDisplay.scrollTop = messageDisplay.scrollHeight;
        }

    }, error => {
        console.error("Error setting up chat listener: ", error);
        document.getElementById('messageDisplay').textContent = "Failed to load messages.";
    });
}


async function sendMessage() {
    if (!currentUser || !currentChatId || !currentChatPartnerId) return;

    const messageInput = document.getElementById('messageInput');
    const content = messageInput.value.trim();

    if (content === '') return;

    try {
        await db.collection('chats').doc(currentChatId).collection('messages').add({
            senderUid: currentUser.uid,
            receiverUid: currentChatPartnerId,
            content: content,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });

        messageInput.value = '';

    } catch (e) {
        console.error("Error sending message: ", e);
        alert("Failed to send message. Check console.");
    }
}


// ----------------------------------------------------
// 7. START APPLICATION
// ----------------------------------------------------
// FIX for jQuery style selector not being available
if (typeof NodeList.prototype.forEach !== 'function') {
    NodeList.prototype.forEach = Array.prototype.forEach;
}
if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
if (!Element.prototype.closest) {
    Element.prototype.closest = function(s) {
        let el = this;
        do {
            if (el.matches(s)) return el;
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
    };
}
// Simple contains polyfill/extension for querySelector
if (window.Element && !Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
document.querySelector = (function(orig) {
    return function(selector) {
        if (selector.includes(':contains')) {
            const [base, text] = selector.split(':contains');
            const target = text.match(/\((.*?)\)/)[1].replace(/['"]/g, '');
            // We use Array.from and find for a safer check instead of NodeList iteration
            return Array.from(document.querySelectorAll(base)).find(e => e.textContent.includes(target));
        }
        return orig.call(this, selector);
    };
})(document.querySelector);

// Initialize Firebase when the script loads
initFirebase();

</script>

</body>
</html>
